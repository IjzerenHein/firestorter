{"version":3,"file":"firestorter.cjs.production.min.js","sources":["../src/Types.ts","../src/init.ts","../node_modules/regenerator-runtime/runtime.js","../src/compat.ts","../src/Utils.ts","../src/enhancedObservable.ts","../src/Document.ts","../src/Collection.ts","../src/AggregateCollection.ts","../src/GeoHash.ts","../src/GeoQuery.ts","../src/index.ts"],"sourcesContent":["import type {\n  DocumentReference,\n  DocumentSnapshot,\n  SnapshotOptions,\n  CollectionReference,\n  Query,\n} from 'firebase/firestore';\nimport type { IContext} from './IContext';\n\nexport { IContext };\n\nexport interface IHasContext {\n  readonly context?: IContext;\n}\n\n/**\n * Document Source.\n */\nexport type DocumentSource =\n  | DocumentReference\n  | string\n  | (() => DocumentReference | string | undefined)\n  | undefined;\n\n/**\n * Document options.\n */\nexport interface IDocumentOptions {\n  schema?: any;\n  snapshot?: DocumentSnapshot;\n  snapshotOptions?: SnapshotOptions;\n  mode?: Mode;\n  debug?: boolean;\n  debugName?: string;\n  context?: IContext;\n}\n\n/**\n * Document interface.\n */\nexport interface IDocument {\n  readonly id: string | undefined;\n}\n\n/**\n * Collection interface.\n */\nexport interface ICollection<T> {\n  readonly docs: T[];\n  readonly hasDocs: boolean;\n}\n\n/**\n * Collection-source.\n */\nexport type CollectionSource =\n  | CollectionReference\n  | string\n  | (() => CollectionReference | string | undefined);\n\n/**\n * Collection-query.\n */\nexport type CollectionQuery = ((ref: CollectionReference) => Query | null | undefined) | Query;\n\n/**\n * Collection options.\n */\nexport interface ICollectionOptions<T> {\n  query?: CollectionQuery;\n  createDocument?: (source: DocumentSource, options: IDocumentOptions) => T;\n  mode?: Mode;\n  debug?: boolean;\n  debugName?: string;\n  minimizeUpdates?: boolean;\n  initialLocalSnapshotDetectTime?: number;\n  initialLocalSnapshotDebounceTime?: number;\n  context?: IContext;\n}\n\n/**\n * Collection document.\n */\nexport interface ICollectionDocument extends IDocument {\n  addCollectionRef(): number;\n  releaseCollectionRef(): number;\n  updateFromCollectionSnapshot(snapshot: DocumentSnapshot): void;\n}\n\n/**\n * Real-time updating mode.\n * @type Mode\n */\nexport enum Mode {\n  Auto = 'auto',\n  On = 'on',\n  Off = 'off',\n}\n\n/**\n * @private\n */\nexport interface IEnhancedObservableDelegate {\n  addObserverRef(): number;\n  releaseObserverRef(): number;\n}\n","import type { IContext, IHasContext} from './Types';\nimport { makeCompatContext,  FirestorterCompatConfig } from './compat';\n\n  let globalContext: IContext;\n  \n  /**\n   * Initializes `firestorter` with the firebase-app.\n   *\n   * @param {IContext | FirestorterCompatConfig} config - Configuration options\n   *\n   * @example\n   * import { initializeApp } from 'firebase/app';\n   * import { getFirestore } from 'firebase/firestore';\n   * import { initFirestorter, Collection, Document } from 'firestorter'; \n   *\n   * // Initialize firebase app\n   * const app = initializeApp({...});\n   * const firestore = getFirestore(app);\n   *\n   * // Initialize `firestorter`\n   * initFirestorter({ app, firestore });\n   *\n   * // Create collection or document\n   * const albums = new Collection('artists/Metallica/albums');\n   * ...\n   * const album = new Document('artists/Metallica/albums/BlackAlbum');\n   * ...\n   */\n  export function initFirestorter(context: IContext | FirestorterCompatConfig) {\n    if (globalContext) {\n      throw new Error(\n        'Firestorter already initialized, did you accidentally call `initFirestorter()` again?'\n      );\n    }\n    // @ts-expect-error Property 'collection' does not exist on type 'IContext | FirestorterCompatConfig'.\n    if (context.collection) {\n      globalContext = context as IContext ;  \n    } else {\n      globalContext = makeCompatContext(context as FirestorterCompatConfig);\n    }\n    return globalContext;\n  }\n  \n  export function getContext(obj?: IHasContext): IContext {\n    if (obj?.context) {\n      return obj.context;\n    }\n  \n    if (globalContext) {\n      return globalContext;\n    }\n  \n    if (obj) {\n      throw new Error(\n        `No context for ${obj} or globally. Did you forget to call \\`initFirestorter\\` or pass {context: ...} option?`\n      );\n    }\n  \n    throw new Error(`No global Firestore context. Did you forget to call \\`initFirestorter\\` ?`);\n  }\n  ","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import type Firebase from 'firebase/compat/app';\n\nimport type { IContext } from './IContext';\n\nexport type FirestorterCompatConfig = {\n  firebase: typeof Firebase;\n  app?: string | Firebase.app.App;\n  firestore?: Firebase.firestore.Firestore;\n};\n\n/**\n * Creates a firestorter compat context.\n *\n * @param {Object} config - Configuration options\n * @param {Firebase} config.firebase - Firebase instance\n * @param {FirebaseApp | string} [config.app] - Firebase app instance or name\n * @param {Firestore} [config.firestore] - Firestore instance\n *\n * @example\n * import firebase from 'firebase/compat/app';\n * import 'firebase/compat/firestore';\n * import { Collection, Document, makeCompatContext } from 'firestorter'\n *\n * // Initialize firebase app\n * firebase.initializeApp({...});\n *\n * // Initialize global `firestorter` context\n * initFirestorter(makeCompatContext({ firebase: firebase }));\n *\n * // Create collection or document\n * const albums = new Collection('artists/Metallica/albums');\n * ...\n * const album = new Document('artists/Metallica/albums/BlackAlbum');\n * ...\n *\n * // Or create a custom context to connect to another Firebase app\n * const app2 = firebase.initializeApp({...});\n * const app2Context = makeCompatContext({ firebase: firebase, app: app2 });\n *\n * // Create collection or document\n * const albums2 = new Collection('artists/Metallica/albums', {context: app2Context});\n * ...\n * const album2 = new Document('artists/Metallica/albums/BlackAlbum', {context: app2Context});\n * ...\n */\nexport function makeCompatContext(config: FirestorterCompatConfig): IContext {\n  const { firebase } = config;\n\n  // Get app instance\n  const app = config.app\n    ? typeof config.app === 'string'\n      ? firebase.app(config.app)\n      : config.app\n    : firebase.app();\n\n  // Get firestore instance\n  const firestore = config.firestore ?? app.firestore();\n  if (!firestore) {\n    throw new Error(\n      \"firebase.firestore() returned `undefined`, did you forget `import 'firebase/firestore';` ?\"\n    );\n  }\n\n  return {\n    // @ts-ignore\n    collection: (path: string) => firestore.collection(path),\n    // @ts-ignore\n    doc: (path: string) => firestore.doc(path),\n    // @ts-ignore\n    getDocs: (ref) => ref.get(),\n    // @ts-ignore\n    where: (fieldPath, opStr, value) => [fieldPath, opStr, value],\n    // @ts-ignore\n    query: (ref, where1, where2, where3) => {\n      // @ts-ignore\n      ref = where1 ? ref.where(where1[0], where1[1], where1[2]) : ref;\n      // @ts-ignore\n      ref = where2 ? ref.where(where2[0], where2[1], where2[2]) : ref;\n      // @ts-ignore\n      ref = where3 ? ref.where(where3[0], where3[1], where3[2]) : ref;\n      return ref;\n    },\n    // @ts-ignore\n    addDoc: (ref, data) => ref.add(data),\n    // @ts-ignore\n    getDoc: (ref) => ref.get(),\n    // @ts-ignore\n    setDoc: (ref, data, options) => ref.set(data, options),\n    // @ts-ignore\n    updateDoc: (ref, fields) => ref.update(fields),\n    // @ts-ignore\n    deleteDoc: (ref) => ref.delete(),\n    // @ts-ignore\n    onSnapshot: (ref, resultFn, errorFn) => ref.onSnapshot(resultFn, errorFn),\n    // @ts-ignore\n    deleteField: () => firebase.firestore.FieldValue.delete(),\n  // @ts-ignore\n    serverTimestamp: () => firebase.firestore.FieldValue.serverTimestamp(),\n  };\n}\n","import isEqual from 'lodash.isequal';\n\nimport { Mode, IHasContext } from './Types';\nimport { getContext } from './init';\n\nexport { isEqual };\n\n/**\n * Helper function which merges data into the source\n * and returns the new object.\n *\n * @param {Object} data - JSON data\n * @param {Object} fields - JSON data that supports field-paths\n * @return {Object} Result\n */\nexport function mergeUpdateData(data: object, fields: object, hasContext?: IHasContext) {\n  const res = {\n    ...data,\n  };\n  const canonicalDelete = getContext(hasContext).deleteField();\n  for (const key in fields) {\n    if (fields.hasOwnProperty(key)) {\n      // @ts-ignore\n      const val = fields[key];\n      const isDelete = canonicalDelete.isEqual\n        ? canonicalDelete.isEqual(val)\n        : isEqual(canonicalDelete, val);\n      const paths = key.split('.');\n      let dataVal: any = res;\n      for (let i = 0; i < paths.length - 1; i++) {\n        if (dataVal[paths[i]] === undefined) {\n          if (isDelete) {\n            dataVal = undefined;\n            break;\n          }\n          dataVal[paths[i]] = {};\n        } else {\n          dataVal[paths[i]] = {\n            ...dataVal[paths[i]],\n          };\n        }\n        dataVal = dataVal[paths[i]];\n      }\n      if (isDelete) {\n        if (dataVal) {\n          delete dataVal[paths[paths.length - 1]];\n        }\n      } else {\n        dataVal[paths[paths.length - 1]] = val;\n      }\n    }\n  }\n  return res;\n}\n\nexport function verifyMode(mode: Mode): Mode {\n  switch (mode) {\n    case 'auto':\n    case 'off':\n    case 'on':\n      return mode;\n    default:\n      throw new Error('Invalid mode mode: ' + mode);\n  }\n}\n\n/**\n * Checks whether the provided value is a valid Firestore Timestamp or Date.\n *\n * Use this function in combination with schemas, in order to validate\n * that the field in the document is indeed a timestamp.\n *\n * @param {Object} val - Value to check\n * @return {Boolean}\n *\n * @example\n * import { isTimestamp } from 'firestorter';\n *\n * const TaskSchema = struct({\n *  name: 'string',\n *  startDate: isTimestamp,\n *  duration: 'number'\n * });\n *\n * const doc = new Document('tasks/mytask', {\n *   schema: TaskSchema\n * });\n * await doc.fetch();\n * console.log('startDate: ', doc.data.startDate.toDate());\n */\nexport function isTimestamp(val: any): boolean {\n  if (val instanceof Date) {\n    return true;\n  }\n  return (\n    typeof val === 'object' &&\n    typeof val.seconds === 'number' &&\n    typeof val.nanoseconds === 'number'\n  );\n}\n","import { observable, onBecomeObserved, onBecomeUnobserved } from 'mobx';\n\nimport { IEnhancedObservableDelegate } from './Types';\n\n/**\n * @ignore\n * Creates an observable which calls addObserverRef &\n * releaseObserverRef methods on the passed-in delegate class.\n * Effectively, this allows Firestorter to track whether\n * a Collection/Document is observed and real-time updating\n * needs to be enabled on it.\n */\nexport function enhancedObservable(data: any, delegate: IEnhancedObservableDelegate): any {\n  const o = Array.isArray(data) ? observable.array(data) : observable.box(data);\n  let isObserved = false;\n  onBecomeUnobserved(o, undefined, () => {\n    if (isObserved) {\n      isObserved = false;\n      delegate.releaseObserverRef();\n    }\n  });\n  onBecomeObserved(o, undefined, () => {\n    if (!isObserved) {\n      isObserved = true;\n      delegate.addObserverRef();\n    }\n  });\n  return o;\n}\n","import type {\n  DocumentReference,\n  DocumentSnapshot,\n  SnapshotOptions,\n  DocumentData,\n} from 'firebase/firestore';\nimport { observable, reaction, toJS, runInAction, IObservableValue } from 'mobx';\n\nimport {\n  DocumentSource,\n  ICollectionDocument,\n  // IDocument,\n  IDocumentOptions,\n  IEnhancedObservableDelegate,\n  Mode,\n  IContext, IHasContext\n} from './Types';\nimport { mergeUpdateData, verifyMode, isEqual } from './Utils';\nimport { enhancedObservable } from './enhancedObservable';\nimport { getContext  } from './init';\n\n/**\n * @private\n */\nfunction resolveRef(value: DocumentSource, hasContext: IHasContext): DocumentReference | undefined {\n  if (typeof value === 'string') {\n    return getContext(hasContext).doc(value);\n  } else if (typeof value === 'function') {\n    return resolveRef(value(), hasContext);\n  } else {\n    return value;\n  }\n}\n\nconst EMPTY_OPTIONS = {};\n\n/**\n * Document represents a document stored in the firestore database.\n * Document is observable so that it can be efficiently linked to for instance\n * a React Component using `mobx-react`'s `observer` pattern. This ensures that\n * a component is only re-rendered when data that is accessed in the `render`\n * function has changed.\n *\n * @param {DocumentSource} [source] String-path, ref or function that returns a path or ref\n * @param {Object} [options] Configuration options\n * @param {String} [options.mode] See `Document.mode` (default: auto)\n * @param {Function} [options.schema] Superstruct schema for data validation\n * @param {firestore.DocumentSnapshot} [options.snapshot] Initial document snapshot\n * @param {firestore.SnapshotOptions} [options.snapshotOptions] Options that configure how data is retrieved from a snapshot\n * @param {boolean} [options.debug] Enables debug logging\n * @param {String} [options.debugName] Name to use when debug logging is enabled\n */\nclass Document<T extends object = object>\n  implements ICollectionDocument, IEnhancedObservableDelegate, IHasContext\n{\n  private sourceInput: DocumentSource;\n  private sourceDisposerFn?: () => void;\n  private refObservable: IObservableValue<DocumentReference<DocumentData>>;\n  private snapshotObservable: IObservableValue<DocumentSnapshot | undefined>;\n  private snapshotOptions?: SnapshotOptions;\n  private docSchema?: (data: object) => object;\n  private isVerbose: boolean;\n  private debugInstanceName?: string;\n  private collectionRefCount: number;\n  private observedRefCount: number;\n  private dataObservable: IObservableValue<T>;\n  private modeObservable: IObservableValue<Mode>;\n  private isLoadingObservable: IObservableValue<boolean>;\n  private onSnapshotUnsubscribeFn?: () => void;\n  private readyPromise?: Promise<void>;\n  private readyResolveFn?: () => void;\n  private ctx?: IContext;\n\n  constructor(source?: DocumentSource, options: IDocumentOptions = {}) {\n    const { schema, snapshot, snapshotOptions, mode, debug, debugName, context } = options;\n    this.debugInstanceName = debugName;\n    this.sourceInput = source;\n    this.ctx = context;\n    this.refObservable = observable.box(resolveRef(source, this));\n    this.docSchema = schema;\n    this.isVerbose = debug || false;\n    this.snapshotObservable = enhancedObservable(snapshot, this);\n    this.snapshotOptions = snapshotOptions;\n    this.collectionRefCount = 0;\n    this.observedRefCount = 0;\n    let data = snapshot ? snapshot.data(this.snapshotOptions) : undefined;\n    if (data) {\n      data = this._validateSchema(data);\n    }\n    this.dataObservable = enhancedObservable(data || EMPTY_OPTIONS, this);\n    this.modeObservable = observable.box(verifyMode(mode || Mode.Auto));\n    this.isLoadingObservable = observable.box(false);\n    this._updateSourceObserver();\n    if (mode === Mode.On) {\n      runInAction(() => this._updateRealtimeUpdates());\n    }\n  }\n\n  /**\n   * Returns the superstruct schema used to validate the\n   * document, or undefined.\n   *\n   * @type {Function}\n   */\n  public get schema(): ((data: any) => any) | undefined {\n    return this.docSchema;\n  }\n\n  /**\n   * Returns the data inside the firestore document.\n   *\n   * @type {Object}\n   *\n   * @example\n   * todos.docs.map((doc) => {\n   *   console.log(doc.data);\n   *   // {\n   *   //   finished: false\n   *   //   text: 'Must do this'\n   *   // }\n   * });\n   */\n  public get data(): T {\n    return this.dataObservable.get();\n  }\n\n  /**\n   * True whenever the document has fetched any data.\n   *\n   * @type {boolean}\n   */\n  public get hasData(): boolean {\n    const { snapshot } = this;\n    if (!snapshot) return false;\n    return typeof snapshot.exists === 'boolean' ? (snapshot.exists as any) : snapshot.exists();\n  }\n\n  /**\n   * Firestore document reference.\n   *\n   * Use this property to get or set the\n   * underlying document reference.\n   *\n   * Alternatively, you can also use `path` to change the\n   * reference in more a readable way.\n   *\n   * @type {firestore.DocumentReference | Function}\n   *\n   * @example\n   * const doc = new Document('albums/splinter');\n   *\n   * // Get the DocumentReference for `albums/splinter`\n   * const ref = doc.ref;\n   *\n   * // Switch to another document\n   * doc.ref = firebase.firestore().doc('albums/americana');\n   */\n  public get ref(): DocumentReference | undefined {\n    return this.refObservable.get();\n  }\n  public set ref(ref: DocumentReference | undefined) {\n    this.source = ref;\n  }\n\n  /**\n   * Id of the firestore document.\n   *\n   * To get the full-path of the document, use `path`.\n   *\n   * @type {string}\n   */\n  public get id(): string | undefined {\n    const ref = this.refObservable.get();\n    return ref ? ref.id : undefined;\n  }\n\n  /**\n   * Path of the document (e.g. 'albums/blackAlbum').\n   *\n   * Use this property to switch to another document in\n   * the back-end. Effectively, it is a more compact\n   * and readable way of setting a new ref.\n   *\n   * @type {string | Function}\n   *\n   * @example\n   * const doc = new Document('artists/Metallica');\n   * ...\n   * // Switch to another document in the back-end\n   * doc.path = 'artists/EaglesOfDeathMetal';\n   *\n   * // Or, you can use a reactive function to link\n   * // to the contents of another document.\n   * const doc2 = new Document('settings/activeArtist');\n   * doc.path = () => 'artists/' + doc2.data.artistId;\n   */\n  public get path(): string | (() => string | undefined) | undefined {\n    // if we call toString() during initialization, eg to throw an error referring to this\n    // document, this would throw an undefined error without the guard.\n    let ref = this.refObservable?.get();\n    if (!ref) {\n      return undefined;\n    }\n    let path = ref.id;\n    while (ref.parent) {\n      path = ref.parent.id + '/' + path;\n      // @ts-ignore\n      ref = ref.parent;\n    }\n    return path;\n  }\n  public set path(documentPath: string | (() => string | undefined) | undefined) {\n    this.source = documentPath;\n  }\n\n  /**\n   * @private\n   */\n  public get source(): DocumentSource {\n    return this.sourceInput;\n  }\n  public set source(source: DocumentSource) {\n    if (this.collectionRefCount) {\n      throw new Error('Cannot change source on Document that is controlled by a Collection');\n    }\n    if (this.sourceInput === source) {\n      return;\n    }\n    this.sourceInput = source;\n    this._updateSourceObserver();\n    runInAction(() => {\n      this.refObservable.set(resolveRef(source, this)!);\n      this._updateRealtimeUpdates(true);\n    });\n  }\n\n  /**\n   * Real-time updating mode.\n   *\n   * Can be set to any of the following values:\n   * - \"auto\" (enables real-time updating when the document becomes observed)\n   * - \"off\" (no real-time updating, you need to call fetch explicitly)\n   * - \"on\" (real-time updating is permanently enabled)\n   *\n   * @type {string}\n   */\n  public get mode(): Mode {\n    return this.modeObservable.get();\n  }\n  public set mode(mode: Mode) {\n    if (this.modeObservable.get() === mode) {\n      return;\n    }\n    verifyMode(mode);\n    runInAction(() => {\n      this.modeObservable.set(mode);\n      this._updateRealtimeUpdates();\n    });\n  }\n\n  /**\n   * Returns true when the Document is actively listening\n   * for changes in the firestore back-end.\n   *\n   * @type {boolean}\n   */\n  public get isActive(): boolean {\n    return !!this.onSnapshotUnsubscribeFn;\n  }\n\n  /**\n   * Underlying firestore snapshot.\n   *\n   * @type {firestore.DocumentSnapshot}\n   */\n  public get snapshot(): DocumentSnapshot | undefined {\n    return this.snapshotObservable.get();\n  }\n\n  /**\n   * Updates one or more fields in the document.\n   *\n   * The update will fail if applied to a document that does\n   * not exist.\n   *\n   * @param {Object} fields - Fields to update\n   * @return {Promise}\n   *\n   * @example\n   * await todoDoc.update({\n   *   finished: true,\n   *   text: 'O yeah, checked this one off',\n   *   foo: {\n   *     bar: 10\n   *   }\n   * });\n   */\n  public update(fields: object): Promise<void> {\n    const ref = this.refObservable.get();\n    if (this.docSchema) {\n      if (!this.snapshot) {\n        console.warn(\n          `${this.debugName} - Unable to verify schema in .update() because the document has not been fetched yet`\n        );\n      } else {\n        try {\n          this._validateSchema(mergeUpdateData(toJS(this.data), fields));\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      }\n    }\n    return getContext(this).updateDoc(ref, fields);\n  }\n\n  /**\n   * Writes to the document.\n   *\n   * If the document does not exist yet, it will be created.\n   * If you pass options, the provided data can be merged into\n   * the existing document.\n   *\n   * @param {Object} data - An object of the fields and values for the document\n   * @param {Object} [options] - Set behaviour options\n   * @param {Boolean} [options.merge] - Set to `true` to only replace the values specified in the data argument. Fields omitted will remain untouched.\n   * @return {Promise}\n   *\n   * @example\n   * const todo = new Document('todos/mynewtodo');\n   * await todo.set({\n   *   finished: false,\n   *   text: 'this is awesome'\n   * });\n   */\n  public set(data: any, options?: any): Promise<void> {\n    if (this.docSchema) {\n      try {\n        if (options?.merge) {\n          this._validateSchema(mergeUpdateData(toJS(this.data), data));\n        } else {\n          this._validateSchema(data);\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n    return getContext(this).setDoc(this.refObservable.get(), data, options);\n  }\n\n  /**\n   * Deletes the document in Firestore.\n   *\n   * Returns a promise that resolves once the document has been\n   * successfully deleted from the backend (Note that it won't\n   * resolve while you're offline).\n   *\n   * @return {Promise}\n   */\n  public delete(): Promise<void> {\n    return getContext(this).deleteDoc(this.refObservable.get());\n  }\n\n  /**\n   * Fetches new data from firestore. Use this to manually fetch\n   * new data when `mode` is set to 'off'.\n   *\n   * @return {Promise}\n   * @fullfil {Document<T>} This document\n   *\n   * @example\n   * const doc = new Document('albums/splinter');\n   * await doc.fetch();\n   * console.log('data: ', doc.data);\n   */\n  public async fetch(): Promise<Document<T>> {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - fetching...`);\n    }\n    if (this.collectionRefCount) {\n      throw new Error('Should not call fetch on Document that is controlled by a Collection');\n    }\n    if (this.isActive) {\n      throw new Error('Should not call fetch when real-time updating is active');\n    }\n    if (this.isLoadingObservable.get()) {\n      throw new Error('Fetch already in progress');\n    }\n    const ref = this.refObservable.get();\n    if (!ref) {\n      throw new Error('No ref or path set on Document');\n    }\n    runInAction(() => {\n      this._ready(false);\n      this.isLoadingObservable.set(true);\n    });\n    try {\n      const snapshot = await getContext(this).getDoc(ref);\n      runInAction(() => {\n        this.isLoadingObservable.set(false);\n        this._updateFromSnapshot(snapshot);\n        if (this.isVerbose) {\n          console.debug(`${this.debugName} - fetched: ${JSON.stringify(toJS(this.data))}`);\n        }\n      });\n      this._ready(true);\n    } catch (err) {\n      console.log(`${this.debugName} - fetch failed: ${(err as Error).message}`);\n      runInAction(() => {\n        this.isLoadingObservable.set(false);\n        this._updateFromSnapshot(undefined);\n        this._ready(true);\n      });\n      throw err;\n    }\n    return this;\n  }\n\n  /**\n   * True when new data is being loaded.\n   *\n   * Loads are performed in these cases:\n   *\n   * - When real-time updating is started\n   * - When a different `ref` or `path` is set\n   * - When a `query` is set or cleared\n   * - When `fetch` is explicitly called\n   *\n   * @type {boolean}\n   *\n   * @example\n   * const doc = new Document('albums/splinter', {mode: 'off'});\n   * console.log(doc.isLoading); \t// false\n   * doc.fetch(); \t\t\t\t\t\t\t\t// start fetch\n   * console.log(doc.isLoading); \t// true\n   * await doc.ready(); \t\t\t\t\t// wait for fetch to complete\n   * console.log(doc.isLoading); \t// false\n   *\n   * @example\n   * const doc = new Document('albums/splinter');\n   * console.log(doc.isLoading); \t// false\n   * const dispose = autorun(() => {\n   *   console.log(doc.data);\t\t\t// start observing document data\n   * });\n   * console.log(doc.isLoading); \t// true\n   * ...\n   * dispose();\t\t\t\t\t\t\t\t\t\t// stop observing document data\n   * console.log(doc.isLoading); \t// false\n   */\n  public get isLoading(): boolean {\n    this.dataObservable.get(); // access data\n    return this.isLoadingObservable.get();\n  }\n\n  /**\n   * True when a snapshot has been obtained from the Firestore\n   * back-end. This property indicates whether an initial fetch/get call\n   * to Firestore has completed processing. This doesn't however mean that data\n   * is available, as the returned snapshot may contain a value indicating\n   * that the document doesn't exist. Use `hasData` to check whether any\n   * data was succesfully retrieved.\n   *\n   * @type {boolean}\n   */\n  public get isLoaded(): boolean {\n    const { snapshot } = this;\n    return !!snapshot;\n  }\n\n  /**\n   * Promise that is resolved when the Document has\n   * data ready to be consumed.\n   *\n   * Use this function to for instance wait for\n   * the initial snapshot update to complete, or to wait\n   * for fresh data after changing the path/ref.\n   *\n   * @return {Promise}\n   *\n   * @example\n   * const doc = new Document('albums/splinter', {mode: 'on'});\n   * await doc.ready();\n   * console.log('data: ', doc.data);\n   *\n   * @example\n   * const doc = new Document('albums/splinter', {mode: 'on'});\n   * await doc.ready();\n   * ...\n   * // Changing the path causes a new snapshot update\n   * doc.path = 'albums/americana';\n   * await doc.ready();\n   * console.log('data: ', doc.data);\n   */\n  public ready(): Promise<void> {\n    this.readyPromise = this.readyPromise || Promise.resolve();\n    return this.readyPromise;\n  }\n\n  public toString(): string {\n    return this.debugName;\n  }\n\n  /**\n   * @private\n   */\n  public get debugName(): string {\n    return `${this.debugInstanceName || this.constructor.name} (${this.path})`;\n  }\n\n  /**\n   * @private\n   */\n  public get context(): IContext | undefined {\n    return this.ctx;\n  }\n\n  /**\n   * Called whenever a property of this class becomes observed.\n   * @private\n   */\n  public addObserverRef(): number {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - addRef (${this.observedRefCount + 1})`);\n    }\n    const res = ++this.observedRefCount;\n    if (res === 1) {\n      runInAction(() => this._updateRealtimeUpdates());\n    }\n    return res;\n  }\n\n  /**\n   * Called whenever a property of this class becomes un-observed.\n   * @private\n   */\n  public releaseObserverRef(): number {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - releaseRef (${this.observedRefCount - 1})`);\n    }\n    const res = --this.observedRefCount;\n    if (!res) {\n      runInAction(() => this._updateRealtimeUpdates());\n    }\n    return res;\n  }\n\n  /**\n   * ICollectionDocument\n   * @private\n   */\n  public addCollectionRef(): number {\n    return ++this.collectionRefCount;\n  }\n  public releaseCollectionRef(): number {\n    return --this.collectionRefCount;\n  }\n  public updateFromCollectionSnapshot(snapshot: DocumentSnapshot): void {\n    return this._updateFromSnapshot(snapshot);\n  }\n\n  /**\n   * @private\n   */\n  public _updateFromSnapshot(snapshot?: DocumentSnapshot): void {\n    let data: any = snapshot ? snapshot.data(this.snapshotOptions) : undefined;\n    if (data) {\n      data = this._validateSchema(data);\n    } else {\n      data = {};\n    }\n    this.snapshotObservable.set(snapshot);\n\n    if (!isEqual(data, this.dataObservable.get())) {\n      this.dataObservable.set(data);\n    }\n  }\n\n  /**\n   * @private\n   */\n  protected _ready(complete: boolean) {\n    if (complete) {\n      const readyResolve = this.readyResolveFn;\n      if (readyResolve) {\n        this.readyResolveFn = undefined;\n        readyResolve();\n      }\n    } else if (!this.readyResolveFn) {\n      this.readyPromise = new Promise((resolve) => {\n        this.readyResolveFn = resolve;\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  protected _onSnapshot(snapshot: DocumentSnapshot) {\n    runInAction(() => {\n      if (this.isVerbose) {\n        console.debug(`${this.debugName} - onSnapshot`);\n      }\n      this.isLoadingObservable.set(false);\n      try {\n        this._updateFromSnapshot(snapshot);\n      } catch (err) {\n        console.error((err as Error).message);\n      }\n      this._ready(true);\n    });\n  }\n\n  /**\n   * @private\n   */\n  protected _onSnapshotError(error: Error): void {\n    console.warn(`${this.debugName} - onSnapshotError: ${error.message}`);\n  }\n\n  /**\n   * @private\n   */\n  private _updateRealtimeUpdates(force?: boolean): void {\n    let newActive = false;\n    switch (this.modeObservable.get()) {\n      case Mode.Auto:\n        newActive = !!this.observedRefCount;\n        break;\n      case Mode.Off:\n        newActive = false;\n        break;\n      case Mode.On:\n        newActive = true;\n        break;\n    }\n\n    // Start/stop listening for snapshot updates\n    if (this.collectionRefCount || !this.refObservable.get()) {\n      newActive = false;\n    }\n    const active = !!this.onSnapshotUnsubscribeFn;\n    if (newActive && (!active || force)) {\n      if (this.isVerbose) {\n        console.debug(\n          `${this.debugName} - ${active ? 're-' : ''}start (${this.modeObservable.get()}:${\n            this.observedRefCount\n          })`\n        );\n      }\n      this._ready(false);\n      this.isLoadingObservable.set(true);\n      this.onSnapshotUnsubscribeFn?.();\n      this.onSnapshotUnsubscribeFn = getContext(this).onSnapshot(\n        this.refObservable.get(),\n        (snapshot) => this._onSnapshot(snapshot),\n        (err) => this._onSnapshotError(err)\n      );\n    } else if (!newActive && active) {\n      if (this.isVerbose) {\n        console.debug(\n          `${this.debugName} - stop (${this.modeObservable.get()}:${this.observedRefCount})`\n        );\n      }\n      this.onSnapshotUnsubscribeFn?.();\n      this.onSnapshotUnsubscribeFn = undefined;\n      if (this.isLoadingObservable.get()) {\n        this.isLoadingObservable.set(false);\n      }\n      this._ready(true);\n    }\n  }\n\n  /**\n   * @private\n   */\n  private _updateSourceObserver() {\n    if (this.sourceDisposerFn) {\n      this.sourceDisposerFn();\n      this.sourceDisposerFn = undefined;\n    }\n    if (typeof this.sourceInput === 'function') {\n      this.sourceDisposerFn = reaction(\n        () => (this.sourceInput as () => DocumentReference | string | undefined)(),\n        (value) => {\n          runInAction(() => {\n            // TODO, check whether path has changed\n            this.refObservable.set(resolveRef(value, this)!);\n            this._updateRealtimeUpdates(true);\n          });\n        }\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  private _validateSchema(data: any): T {\n    if (!this.docSchema) {\n      return data;\n    }\n    try {\n      data = this.docSchema(data);\n    } catch (err) {\n      // console.log(JSON.stringify(err));\n\n      throw new Error(\n        'Invalid value at \"' +\n          (err as any).path +\n          '\" for ' +\n          (this.debugInstanceName || this.constructor.name) +\n          ' with id \"' +\n          this.id +\n          '\": ' +\n          (err as Error).message\n      );\n    }\n    return data;\n  }\n}\n\nexport default Document;\n","import type {\n  Query,\n  CollectionReference,\n  QuerySnapshot,\n  SnapshotListenOptions,\n  DocumentSnapshot,\n} from 'firebase/firestore';\nimport { IObservableArray, IObservableValue, observable, reaction, runInAction } from 'mobx';\n\nimport Document from './Document';\nimport {\n  CollectionQuery,\n  CollectionSource,\n  DocumentSource,\n  ICollectionDocument,\n  ICollectionOptions,\n  ICollection,\n  IDocumentOptions,\n  IEnhancedObservableDelegate,\n  Mode,\n  IContext, IHasContext\n} from './Types';\nimport { verifyMode } from './Utils';\nimport { enhancedObservable } from './enhancedObservable';\nimport { getContext } from './init';\n\n// * @param {Number} [options.limit] Maximum number of documents to fetch (see `Collection.limit`)\n\n/**\n * The Collection class lays at the heart of `firestorter`.\n * It represents a collection in Firestore and its queried data. It is\n * observable so that it can be efficiently linked to a React Component\n * using `mobx-react`'s `observer` pattern.\n *\n * Collection supports three modes of real-time updating:\n * - \"auto\" (real-time updating is enabled on demand) (default)\n * - \"on\" (real-time updating is permanently turned on)\n * - \"off\" (real-time updating is turned off, use `.fetch` explicitly)\n *\n * The \"auto\" mode ensures that Collection only communicates with\n * the firestore back-end whever the Collection is actually\n * rendered by a Component. This prevents unneccesary background\n * updates and leads to the best possible performance.\n *\n * When real-time updates are enabled, data is automatically fetched\n * from Firestore whenever it changes in the back-end (using `onSnapshot`).\n * This enables almost magical instant updates. When data is changed,\n * only those documents are updated that have actually changed. Document\n * objects are re-used where possible, and just their data is updated.\n * The same is true for the `docs` property. If no documents where\n * added, removed, re-ordered, then the `docs` property itself will not\n * change.\n *\n * Alternatively, you can keep real-time updates turned off and fetch\n * manually. This will update the Collection as efficiently as possible.\n * If nothing has changed on the back-end, no new Documents would be\n * created or modified.\n *\n * @param {CollectionSource} [source] String-path, ref or function that returns a path or ref\n * @param {Object} [options] Configuration options\n * @param {Function|Query} [options.query] See `Collection.query`\n * @param {String} [options.mode] See `Collection.mode`\n * @param {Function} [options.createDocument] Factory function for creating documents `(source, options) => new Document(source, options)`\n * @param {boolean} [options.minimizeUpdates] Enables additional algorithms to reduces updates to your app (e.g. when snapshots are received in rapid succession)\n * @param {boolean} [options.debug] Enables debug logging\n * @param {String} [options.debugName] Name to use when debug logging is enabled\n *\n * @example\n * import {Collection} from 'firestorter';\n *\n * // Create a collection using path (preferred)\n * const col = new Collection('artists/Metallica/albums');\n *\n * // Create a collection using a reference\n * const col2 = new Collection(firebase.firestore().collection('todos'));\n *\n * // Create a collection and permanently start real-time updating\n * const col2 = new Collection('artists', {\n *   mode: 'on'\n * });\n *\n * // Create a collection with a query on it\n * const col3 = new Collection('artists', {\n *   query: (ref) => ref.orderBy('name', 'asc')\n * });\n *\n * @example\n * // In manual mode, just call `fetch` explicitly\n * const col = new Collection('albums', {mode: 'off'});\n * col.fetch().then((collection) => {\n *   collection.docs.forEach((doc) => console.log(doc));\n * });\n *\n * // Yo can use the `isLoading` property to see whether a fetch\n * // is in progress\n * console.log(col.isLoading);\n */\nclass Collection<T extends ICollectionDocument = Document>\n  implements ICollection<T>, IEnhancedObservableDelegate, IHasContext\n{\n  private sourceInput?: CollectionSource;\n  private sourceCache?: CollectionSource;\n  private sourceCacheRef?: CollectionReference;\n  private refDisposerFn?: () => void;\n  private refObservable: IObservableValue<CollectionReference | undefined>;\n  private queryInput?: CollectionQuery;\n  private queryRefObservable: IObservableValue<Query | null | undefined>;\n  private onSnapshotRefCache: Query | undefined | null;\n  private modeObservable: IObservableValue<Mode>;\n  private isLoadingObservable: IObservableValue<boolean>;\n  private isLoadedObservable: IObservableValue<boolean>;\n  private docLookup: { [name: string]: T };\n  private docsObservable: IObservableArray<T>;\n  private hasDocsObservable: IObservableValue<boolean>;\n  private createDocument: (source: DocumentSource, options: IDocumentOptions) => T;\n  private onSnapshotUnsubscribe?: () => void;\n  private observedRefCount: number;\n  private isVerbose: boolean;\n  private debugInstanceName?: string;\n  private isMinimizingUpdates: boolean;\n  private initialLocalSnapshotDetectTime?: number;\n  private initialLocalSnapshotDebounceTime?: number;\n  private readyPromise?: Promise<null>;\n  private readyResolveFn?: (value: PromiseLike<null> | null) => void;\n  private initialLocalSnapshotStartTime?: number;\n  private initialLocalSnapshotDebounceTimer?: any;\n  private ctx?: IContext;\n  // private _limit: any;\n  // private _cursor: any;\n\n  constructor(source?: CollectionSource, options: ICollectionOptions<T> = {}) {\n    const {\n      query,\n      createDocument,\n      mode,\n      // limit,\n      debug,\n      debugName,\n      minimizeUpdates = false,\n      initialLocalSnapshotDetectTime = 50,\n      initialLocalSnapshotDebounceTime = 1000,\n      context,\n    } = options;\n    this.isVerbose = debug || false;\n    this.debugInstanceName = debugName;\n    this.isMinimizingUpdates = minimizeUpdates;\n    this.initialLocalSnapshotDetectTime = initialLocalSnapshotDetectTime;\n    this.initialLocalSnapshotDebounceTime = initialLocalSnapshotDebounceTime;\n    this.docLookup = {};\n    this.observedRefCount = 0;\n    this.sourceInput = source;\n    this.refObservable = observable.box(undefined);\n    this.queryInput = query;\n    this.queryRefObservable = observable.box(undefined);\n    // this._limit = observable.box(limit || undefined);\n    // this._cursor = observable.box(undefined);\n    this.modeObservable = observable.box(verifyMode(mode || Mode.Auto));\n    this.isLoadingObservable = observable.box(false);\n    this.isLoadedObservable = observable.box(false);\n    this.hasDocsObservable = enhancedObservable(false, this);\n    this.docsObservable = enhancedObservable([], this);\n    this.ctx = context;\n\n    if (createDocument) {\n      this.createDocument = createDocument;\n    } else {\n      this.createDocument = (docSource: DocumentSource, docOptions: IDocumentOptions): T =>\n        new Document(docSource, docOptions) as unknown as T;\n    }\n\n    runInAction(() => this._updateRealtimeUpdates(true, true));\n  }\n\n  /**\n   * Array of all the documents that have been fetched\n   * from firestore.\n   *\n   * @type {Array}\n   *\n   * @example\n   * collection.docs.forEach((doc) => {\n   *   console.log(doc.data);\n   * });\n   */\n  public get docs(): T[] {\n    return this.docsObservable;\n  }\n\n  /**\n   * True whenever the docs array is not empty.\n   *\n   * @type {boolean}\n   */\n  public get hasDocs(): boolean {\n    return this.hasDocsObservable.get();\n  }\n\n  /**\n   * Firestore collection reference.\n   *\n   * Use this property to get or set the collection\n   * reference. When set, a fetch to the new collection\n   * is performed.\n   *\n   * Alternatively, you can also use `path` to change the\n   * reference in more a readable way.\n   *\n   * @type {firestore.CollectionReference | Function}\n   *\n   * @example\n   * const col = new Collection(firebase.firestore().collection('albums/splinter/tracks'));\n   * ...\n   * // Switch to another collection\n   * col.ref = firebase.firestore().collection('albums/americana/tracks');\n   */\n  public get ref(): CollectionReference | undefined {\n    let ref = this.refObservable.get();\n    if (!this.refDisposerFn) {\n      ref = this._resolveRef(this.sourceInput);\n    }\n    return ref;\n  }\n  public set ref(ref: CollectionReference | undefined) {\n    this.source = ref;\n  }\n\n  /**\n   * Id of the Firestore collection (e.g. 'tracks').\n   *\n   * To get the full-path of the collection, use `path`.\n   *\n   * @type {string}\n   */\n  public get id(): string | undefined {\n    const ref = this.ref;\n    return ref ? ref.id : undefined;\n  }\n\n  /**\n   * Path of the collection (e.g. 'albums/blackAlbum/tracks').\n   *\n   * Use this property to switch to another collection in\n   * the back-end. Effectively, it is a more compact\n   * and readable way of setting a new ref.\n   *\n   * @type {string | Function}\n   *\n   * @example\n   * const col = new Collection('artists/Metallica/albums');\n   * ...\n   * // Switch to another collection in the back-end\n   * col.path = 'artists/EaglesOfDeathMetal/albums';\n   */\n  public get path(): string | undefined {\n    let ref: any = this.ref;\n    if (!ref) {\n      return undefined;\n    }\n    let path = ref.id;\n    while (ref.parent) {\n      path = ref.parent.id + '/' + path;\n      ref = ref.parent;\n    }\n    return path;\n  }\n  public set path(collectionPath: string | undefined) {\n    this.source = collectionPath;\n  }\n\n  /**\n   * @private\n   */\n  public get source(): CollectionSource | undefined {\n    return this.sourceInput;\n  }\n  public set source(source: CollectionSource | undefined) {\n    if (this.sourceInput === source) {\n      return;\n    }\n    runInAction(() => {\n      this.sourceInput = source;\n\n      // Stop any reactions\n      if (this.refDisposerFn) {\n        this.refDisposerFn();\n        this.refDisposerFn = undefined;\n      }\n\n      // Update real-time updating\n      this._updateRealtimeUpdates(true);\n    });\n  }\n\n  /**\n   * Use this property to set any order-by, where,\n   * limit or start/end criteria. When set, that query\n   * is used to retrieve any data. When cleared (`undefined`),\n   * the collection reference is used.\n   *\n   * The query can be a Function of the form\n   * `(firestore.CollectionReference) => firestore.Query | null | undefined`.\n   * Where returning `null` will result in an empty collection,\n   * and returning `undefined` will revert to using the collection\n   * reference (the entire collection).\n   *\n   * If the query function makes use of any observable values then\n   * it will be re-run when those values change.\n   *\n   * query can be set to a direct Firestore `Query` object but this\n   * is an uncommon usage.\n   *\n   * @type {firestore.Query | Function}\n   *\n   * @example\n   * const todos = new Collection('todos');\n   *\n   * // Sort the collection\n   * todos.query = (ref) => ref.orderBy('text', 'asc');\n   *\n   * // Order, filter & limit\n   * todos.query = (ref) => ref.where('finished', '==', false).orderBy('finished', 'asc').limit(20);\n   *\n   * // React to changes in observable and force empty collection when required\n   * todos.query = (ref) => authStore.uid ? ref.where('owner', '==', authStore.uid) : null;\n   *\n   * // Clear the query, will cause whole collection to be fetched\n   * todos.query = undefined;\n   */\n  public get query(): CollectionQuery | undefined {\n    return this.queryInput;\n  }\n  public set query(query: CollectionQuery | undefined) {\n    if (this.queryInput === query) {\n      return;\n    }\n    runInAction(() => {\n      this.queryInput = query;\n\n      // Stop any reactions\n      if (this.refDisposerFn) {\n        this.refDisposerFn();\n        this.refDisposerFn = undefined;\n      }\n\n      // Update real-time updating\n      this._updateRealtimeUpdates(undefined, true);\n    });\n  }\n\n  /**\n   * @private\n   * firestore.Query -> a valid query exists, use that\n   * null -> the query function returned `null` to disable the collection\n   * undefined -> no query defined, use collection ref instead\n   */\n  public get queryRef(): Query | null | undefined {\n    return this.queryRefObservable.get();\n  }\n\n  /**\n   * Real-time updating mode.\n   *\n   * Can be set to any of the following values:\n   * - \"auto\" (enables real-time updating when the collection is observed)\n   * - \"off\" (no real-time updating, you need to call fetch explicitly)\n   * - \"on\" (real-time updating is permanently enabled)\n   *\n   * @type {string}\n   */\n  public get mode(): Mode {\n    return this.modeObservable.get();\n  }\n  public set mode(mode: Mode) {\n    if (this.modeObservable.get() === mode) {\n      return;\n    }\n    verifyMode(mode);\n    runInAction(() => {\n      this.modeObservable.set(mode);\n      this._updateRealtimeUpdates();\n    });\n  }\n\n  /**\n   * Returns true when the Collection is actively listening\n   * for changes in the firestore back-end.\n   *\n   * @type {boolean}\n   */\n  public get isActive(): boolean {\n    return !!this.onSnapshotUnsubscribe;\n  }\n\n  /**\n   * Fetches new data from firestore. Use this to manually fetch\n   * new data when `mode` is set to 'off'.\n   *\n   * @return {Promise}\n   * @fulfil {Collection} - This collection\n   * @reject {Error} - Error describing the cause of the problem\n   *\n   * @example\n   * const col = new Collection('albums', 'off');\n   * col.fetch().then(({docs}) => {\n   *   docs.forEach(doc => console.log(doc));\n   * });\n   */\n  public async fetch(): Promise<Collection<T>> {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - fetching...`);\n    }\n    if (this.isActive) {\n      throw new Error('Should not call fetch when real-time updating is active');\n    }\n    if (this.isLoadingObservable.get()) {\n      throw new Error('Fetch already in progress');\n    }\n    const colRef = this._resolveRef(this.sourceInput);\n    const queryRef = this._resolveQuery(colRef!, this.queryInput);\n    const ref = queryRef !== undefined ? queryRef : colRef;\n    if (!ref) {\n      throw new Error('No ref, path or query set on Collection');\n    }\n    runInAction(() => {\n      this._ready(false);\n      this.isLoadingObservable.set(true);\n    });\n    try {\n      const snapshot = await getContext(this).getDocs(ref);\n      runInAction(() => {\n        this.isLoadingObservable.set(false);\n        this._updateFromSnapshot(snapshot);\n        if (this.isVerbose) {\n          console.debug(`${this.debugName} - fetched ${snapshot.docs.length} documents`);\n        }\n      });\n      this._ready(true);\n      return this;\n    } catch (err) {\n      console.log(`${this.debugName} - fetch failed: ${(err as Error).message}`);\n      runInAction(() => {\n        this.isLoadingObservable.set(false);\n        this._updateFromSnapshot(undefined);\n        this._ready(true);\n      });\n      throw err;\n    }\n  }\n\n  /**\n   * True when new data is being loaded.\n   *\n   * Fetches are performed in these cases:\n   *\n   * - When real-time updating is started\n   * - When a different `ref` or `path` is set\n   * - When a `query` is set or cleared\n   * - When `fetch` is explicitly called\n   *\n   * @type {boolean}\n   *\n   * @example\n   * const col = new Collection('albums', {mode: 'off'});\n   * console.log(col.isLoading);  // false\n   * col.fetch();                 // start fetch\n   * console.log(col.isLoading);  // true\n   * await col.ready();           // wait for fetch to complete\n   * console.log(col.isLoading);  // false\n   *\n   * @example\n   * const col = new Collection('albums');\n   * console.log(col.isLoading);  // false\n   * const dispose = autorun(() => {\n   *   console.log(col.docs);     // start observing collection data\n   * });\n   * console.log(col.isLoading);  // true\n   * ...\n   * dispose();                   // stop observing collection data\n   * console.log(col.isLoading);  // false\n   */\n  public get isLoading(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions, @babel/no-unused-expressions\n    this.docsObservable.length;\n    return this.isLoadingObservable.get();\n  }\n\n  /**\n   * True when a query snapshot has been retrieved at least once.\n   * This however does not mean that any documents have been retrieved,\n   * as the number of returned document may have been 0.\n   * Use `hasDocs` to check whether any documents have been retrieved.\n   *\n   * @type {boolean}\n   */\n  public get isLoaded(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions, @babel/no-unused-expressions\n    this.docsObservable.length;\n    return this.isLoadedObservable.get();\n  }\n\n  /**\n   * Promise that is resolved when the Collection has\n   * finished fetching its (initial) documents.\n   *\n   * Use this method to for instance wait for\n   * the initial snapshot update to complete, or to wait\n   * for fresh data after changing the path/ref.\n   *\n   * @return {Promise}\n   *\n   * @example\n   * const col = new Collection('albums', {mode: 'on'});\n   * await col.ready();\n   * console.log('albums: ', col.docs);\n   *\n   * @example\n   * const col = new Collection('artists/FooFighters/albums', {mode: 'on'});\n   * await col.ready();\n   * ...\n   * // Changing the path causes a new snapshot update\n   * col.path = 'artists/TheOffspring/albums';\n   * await col.ready();\n   * console.log('albums: ', col.docs);\n   */\n  public ready(): Promise<null> {\n    this.readyPromise = this.readyPromise || Promise.resolve(null);\n    return this.readyPromise;\n  }\n\n  /**\n   * Add a new document to this collection with the specified\n   * data, assigning it a document ID automatically.\n   *\n   * @param {Object} data - JSON data for the new document\n   * @return {Promise}\n   * @fulfil {Document} - The newly created document\n   * @reject {Error} - Error, e.g. a schema validation error or Firestore error\n   *\n   * @example\n   * const doc = await collection.add({\n   *   finished: false,\n   *   text: 'New todo',\n   *   options: {\n   *     highPrio: true\n   *   }\n   * });\n   * console.log(doc.id); // print id of new document\n   *\n   * @example\n   * // If you want to create a document with a custom Id, then\n   * // use the Document class instead, like this\n   * const docWithCustomId = new Document('todos/mytodoid');\n   * await docWithCustomId.set({\n   *   finished: false,\n   *   text: 'New todo',\n   * });\n   */\n  public async add(data: any): Promise<T> {\n    const ref = this.ref;\n    if (!ref) {\n      throw new Error('No valid collection reference');\n    }\n\n    // REVISIT: can we know to skip this if schemas not in use?\n    // Validate schema using a dummy snapshot\n    this.createDocument(undefined, {\n      context: this.context,\n      snapshot: {\n        data: () => data,\n        exists: () => true,\n        get: (fieldPath: string) => data[fieldPath],\n        id: '',\n        // @ts-ignore Type 'undefined' is not assignable to type 'SnapshotMetadata'\n        metadata: undefined,\n        // @ts-ignore Type 'undefined' is not assignable to type 'DocumentReference<DocumentData>'\n        ref: undefined,\n      },\n    });\n\n    // Add to firestore\n    const { addDoc, getDoc } = getContext(this);\n    const ref2 = await addDoc(ref, data);\n    const snapshot = await getDoc(ref2);\n    return this.createDocument(snapshot.ref, {\n      context: this.context,\n      snapshot,\n    });\n  }\n\n  /**\n   * Deletes all the documents in the collection or query.\n   * @ignore\n   * TODO - Not implemented yet\n   */\n  public async deleteAll(): Promise<void> {\n    const ref = this.ref;\n    if (!ref) {\n      throw new Error('No valid collection reference');\n    }\n    // TODO\n  }\n\n  public toString(): string {\n    return this.debugName;\n  }\n\n  /**\n   * @private\n   */\n  public get debugName(): string {\n    return `${this.debugInstanceName || this.constructor.name} (${this.path})`;\n  }\n\n  /**\n   * @private\n   */\n  public get context(): IContext | undefined{\n    return this.ctx;\n  }\n\n  /**\n   * Limit used for query pagination.\n   */\n  /* get limit(): ?number {\n\t\treturn this._limit.get();\n\t}\n\tset limit(val: ?number) {\n\t\tthis._limit.set(val || undefined);\n\t} */\n\n  /**\n   * Paginates to the start of the collection,\n   * resetting any pagination cursor that exists.\n   */\n  /* paginateToStart() {\n\t\tthis._cursor.set(undefined);\n\t} */\n\n  /**\n   * Paginates to the next page. This sets the cursor\n   * to `startAfter` the last document.\n   *\n   * @return {Boolean} False in case pagination was not possible\n   */\n  /* paginateNext(): boolean {\n\t\tif (!this.canPaginateNext) return false;\n\t\tthis._cursor.set({\n\t\t\ttype: 'startAfter',\n\t\t\tvalue: this.docs[this.docs.length - 1].ref\n\t\t});\n\t\treturn true;\n\t} */\n\n  /**\n   * Paginates to the previous page. This sets the cursor\n   * to `endBefore` the first document in `docs`.\n   *\n   * @return {Boolean} False in case pagination was not possible\n   */\n  /* paginatePrevious(): boolean {\n\t\tif (!this.canPaginatePrevious) return false;\n\t\tif (!this.docs.length) {\n\t\t\tthis._cursor.set(undefined);\n\t\t\treturn true;\n\t\t}\n\t\tthis._cursor.set({\n\t\t\ttype: 'endBefore',\n\t\t\tvalue: this.docs[0].ref\n\t\t});\n\t\treturn true;\n\t}\n\n\tget canPaginateNext(): boolean {\n\t\tif (!this.limit) return false;\n\t\treturn this.docs.length >= this.limit;\n\t}\n\n\tget canPaginatePrevious(): boolean {\n\t\tif (!this.limit) return false;\n\t\treturn this._cursor.get() ? true : false;\n\t} */\n\n  /**\n   * Called whenever a property of this class becomes observed.\n   * @private\n   */\n  public addObserverRef(): number {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - addRef (${this.observedRefCount + 1})`);\n    }\n    const res = ++this.observedRefCount;\n    if (res === 1) {\n      runInAction(() => this._updateRealtimeUpdates());\n    }\n    return res;\n  }\n\n  /**\n   * Called whenever a property of this class becomes un-observed.\n   * @private\n   */\n  public releaseObserverRef(): number {\n    if (this.isVerbose) {\n      console.debug(`${this.debugName} - releaseRef (${this.observedRefCount - 1})`);\n    }\n    const res = --this.observedRefCount;\n    if (!res) {\n      runInAction(() => this._updateRealtimeUpdates());\n    }\n    return res;\n  }\n\n  protected _ready(complete: boolean) {\n    if (complete) {\n      const readyResolve = this.readyResolveFn;\n      if (readyResolve) {\n        this.readyResolveFn = undefined;\n        readyResolve(null);\n      }\n    } else if (!this.readyResolveFn) {\n      this.readyPromise = new Promise((resolve) => {\n        this.readyResolveFn = resolve;\n      });\n    }\n  }\n\n  protected _resolveRef(source?: CollectionSource): CollectionReference | undefined{\n    if (this.sourceCache === source) {\n      return this.sourceCacheRef;\n    }\n    let ref;\n    if (typeof source === 'string') {\n      ref = getContext(this).collection(source);\n    } else if (typeof source === 'function') {\n      ref = this._resolveRef(source());\n      return ref; // don't set cache in this case\n    } else {\n      ref = source;\n    }\n    this.sourceCache = source;\n    this.sourceCacheRef = ref;\n    return ref;\n  }\n\n  protected _resolveQuery(\n    collectionRef: CollectionReference,\n    query?: CollectionQuery\n  ): Query | null | undefined {\n    let ref: any = query;\n    if (typeof query === 'function') {\n      ref = query(collectionRef);\n    }\n\n    // Apply pagination cursor\n    /* const cursor = this._cursor.get();\n\t\tif (cursor) {\n\t\t\tref = ref || collectionRef;\n\t\t\tswitch (cursor.type) {\n\t\t\t\tcase 'startAfter': ref = ref.startAfter(cursor.value); break;\n\t\t\t\tcase 'startAt': ref = ref.startAt(cursor.value); break;\n\t\t\t\tcase 'endBefore': ref = ref.endBefore(cursor.value); break;\n\t\t\t\tcase 'endAt': ref = ref.endAt(cursor.value); break;\n\t\t\t}\n\t\t}\n\n\t\t// Apply fetch limit\n\t\tconst limit = this.limit;\n\t\tif (limit) {\n\t\t\tref = ref || collectionRef;\n\t\t\tref = ref.limit(limit);\n\t\t} */\n    return ref;\n  }\n\n  /**\n   * @private\n   */\n  protected _onSnapshot(snapshot: QuerySnapshot): void {\n    // Firestore sometimes returns multiple snapshots initially.\n    // The first one containing cached results, followed by a second\n    // snapshot which was fetched from the cloud.\n    if (this.initialLocalSnapshotDebounceTimer) {\n      clearTimeout(this.initialLocalSnapshotDebounceTimer);\n      this.initialLocalSnapshotDebounceTimer = undefined;\n      if (this.isVerbose) {\n        console.debug(\n          `${this.debugName} - cancelling initial debounced snapshot, because a newer snapshot has been received`\n        );\n      }\n    }\n    if (this.isMinimizingUpdates) {\n      const timeElapsed = Date.now() - (this.initialLocalSnapshotStartTime ?? 0);\n      this.initialLocalSnapshotStartTime = 0;\n      if (timeElapsed >= 0 && timeElapsed < (this.initialLocalSnapshotDetectTime ?? 0)) {\n        if (this.isVerbose) {\n          console.debug(\n            `${this.debugName} - local snapshot detected (${timeElapsed}ms < ${this.initialLocalSnapshotDetectTime}ms threshold), debouncing ${this.initialLocalSnapshotDebounceTime} msec...`\n          );\n        }\n        this.initialLocalSnapshotDebounceTimer = setTimeout(() => {\n          this.initialLocalSnapshotDebounceTimer = undefined;\n          this._onSnapshot(snapshot);\n        }, this.initialLocalSnapshotDebounceTime);\n        return;\n      }\n    }\n\n    // Process snapshot\n    runInAction(() => {\n      if (this.isVerbose) {\n        console.debug(`${this.debugName} - onSnapshot`);\n      }\n      this.isLoadingObservable.set(false);\n      this._updateFromSnapshot(snapshot);\n      this._ready(true);\n    });\n  }\n\n  /**\n   * @private\n   */\n  protected _onSnapshotError(error: Error): void {\n    console.warn(`${this.debugName} - onSnapshotError: ${error.message}`);\n  }\n\n  /**\n   * @private\n   */\n  private _updateFromSnapshot(snapshot?: QuerySnapshot): void {\n    const newDocs: T[] = [];\n    if (snapshot) {\n      snapshot.docs.forEach((docSnapshot: DocumentSnapshot) => {\n        let doc = this.docLookup[docSnapshot.id];\n        try {\n          if (doc) {\n            doc.updateFromCollectionSnapshot(docSnapshot);\n          } else {\n            doc = this.createDocument(docSnapshot.ref, {\n              context: this.context,\n              snapshot: docSnapshot,\n            });\n            this.docLookup[doc.id!] = doc;\n          }\n          doc.addCollectionRef();\n          newDocs.push(doc);\n        } catch (err) {\n          console.error((err as Error).message);\n        }\n      });\n    }\n    this.docsObservable.forEach((doc) => {\n      if (!doc.releaseCollectionRef()) {\n        delete this.docLookup[doc.id || ''];\n      }\n    });\n\n    this.hasDocsObservable.set(!!newDocs.length);\n    this.isLoadedObservable.set(true);\n    if (this.docsObservable.length !== newDocs.length) {\n      this.docsObservable.replace(newDocs);\n    } else {\n      for (let i = 0, n = newDocs.length; i < n; i++) {\n        if (newDocs[i] !== this.docsObservable[i]) {\n          this.docsObservable.replace(newDocs);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  private _updateRealtimeUpdates(updateSourceRef?: boolean, updateQueryRef?: boolean): void {\n    let newActive = false;\n    const active = !!this.onSnapshotUnsubscribe;\n    switch (this.modeObservable.get()) {\n      case Mode.Auto:\n        newActive = !!this.observedRefCount;\n        break;\n      case Mode.Off:\n        newActive = false;\n        break;\n      case Mode.On:\n        newActive = true;\n        break;\n    }\n\n    // Update source & query ref if needed\n    if (newActive && !active) {\n      updateSourceRef = true;\n      updateQueryRef = true;\n    }\n    if (updateSourceRef) {\n      this.refObservable.set(this._resolveRef(this.sourceInput));\n    }\n    if (updateQueryRef) {\n      this.queryRefObservable.set(this._resolveQuery(this.refObservable.get()!, this.queryInput));\n    }\n\n    // Upon de-activation, stop any observed reactions or\n    // snapshot listeners.\n    if (!newActive) {\n      if (this.refDisposerFn) {\n        this.refDisposerFn();\n        this.refDisposerFn = undefined;\n      }\n      this.onSnapshotRefCache = undefined;\n      if (this.onSnapshotUnsubscribe) {\n        if (this.isVerbose) {\n          console.debug(\n            `${this.debugName} - stop (${this.modeObservable.get()}:${this.observedRefCount})`\n          );\n        }\n        this.onSnapshotUnsubscribe();\n        this.onSnapshotUnsubscribe = undefined;\n        if (this.isLoadingObservable.get()) {\n          this.isLoadingObservable.set(false);\n        }\n        this._ready(true);\n      }\n      return;\n    }\n\n    // Start listening for ref-changes\n    if (!this.refDisposerFn) {\n      let initialSourceRef = this.refObservable.get();\n      let initialQueryRef = this.queryRefObservable.get();\n      this.refDisposerFn = reaction(\n        () => {\n          let sourceRef = this._resolveRef(this.sourceInput);\n          let queryRef2 = this._resolveQuery(sourceRef!, this.queryInput);\n          if (initialSourceRef) {\n            sourceRef = initialSourceRef;\n            queryRef2 = initialQueryRef;\n            initialSourceRef = undefined;\n            initialQueryRef = undefined;\n          }\n          return {\n            queryRef2,\n            sourceRef,\n          };\n        },\n        ({ sourceRef, queryRef2 }) => {\n          runInAction(() => {\n            if (\n              this.refObservable.get() !== sourceRef ||\n              this.queryRefObservable.get() !== queryRef2\n            ) {\n              this.refObservable.set(sourceRef);\n              this.queryRefObservable.set(queryRef2);\n              this._updateRealtimeUpdates();\n            }\n          });\n        }\n      );\n    }\n\n    // Resolve ref and check whether it has changed\n    const queryRef = this.queryRefObservable.get();\n    const ref = queryRef !== undefined ? queryRef : this.refObservable.get();\n    if (this.onSnapshotRefCache === ref) {\n      return;\n    }\n    this.onSnapshotRefCache = ref;\n\n    // Stop any existing listener\n    if (this.onSnapshotUnsubscribe) {\n      this.onSnapshotUnsubscribe();\n      this.onSnapshotUnsubscribe = undefined;\n    }\n\n    // If no valid ref exists, then clear the collection so no \"old\"\n    // documents are visible.\n    if (!ref) {\n      if (this.docsObservable.length) {\n        this._updateFromSnapshot({\n          docChanges: (options?: SnapshotListenOptions) => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions, @babel/no-unused-expressions\n            options;\n            return [];\n          },\n          docs: [],\n          empty: true,\n          forEach: () => true,\n          // @ts-ignore Type 'undefined' is not assignable to type 'SnapshotMetadata'\n          metadata: undefined,\n          query: queryRef!,\n          size: 0,\n        });\n      }\n      return;\n    }\n\n    // Start listener\n    if (this.isVerbose) {\n      console.debug(\n        `${this.debugName} - ${active ? 're-' : ''}start (${this.modeObservable.get()}:${\n          this.observedRefCount\n        })`\n      );\n    }\n    this._ready(false);\n    this.isLoadingObservable.set(true);\n    this.initialLocalSnapshotStartTime = Date.now();\n    this.onSnapshotUnsubscribe = getContext(this).onSnapshot(\n      ref,\n      (snapshot) => this._onSnapshot(snapshot),\n      (err) => this._onSnapshotError(err)\n    );\n  }\n}\n\nexport default Collection;\n","import type { CollectionReference, Query } from 'firebase/firestore';\nimport { runInAction, autorun, computed, makeObservable, IObservableArray } from 'mobx';\n\nimport Collection from './Collection';\nimport Document from './Document';\nimport {\n  ICollection,\n  DocumentSource,\n  IDocumentOptions,\n  CollectionSource,\n  ICollectionDocument,\n  IEnhancedObservableDelegate,\n  IContext, IHasContext\n} from './Types';\nimport { isEqual } from './Utils';\nimport { enhancedObservable } from './enhancedObservable';\n\nexport type AggregateCollectionOrderBy<T> = (a: T, b: T) => number;\nexport type AggregateCollectionFilterBy<T> = (doc: T) => boolean;\nexport interface IAggregateCollectionQuery {\n  key: string;\n  query: (ref: CollectionReference) => Query | null | undefined;\n}\nexport type AggregateCollectionQueries<Y> = Y[] | null;\nexport type AggregateCollectionQueriesFn<Y extends IAggregateCollectionQuery> =\n  () => AggregateCollectionQueries<Y>;\n\nexport interface IAggregateCollectionOptions<T, Y extends IAggregateCollectionQuery> {\n  queries: AggregateCollectionQueriesFn<Y>;\n  createDocument?: (source: DocumentSource, options: IDocumentOptions) => T;\n  debug?: boolean;\n  debugName?: string;\n  orderBy?: AggregateCollectionOrderBy<T>;\n  filterBy?: AggregateCollectionFilterBy<T>;\n  context?: IContext;\n}\n\n/**\n * Collection that aggregates documents from multiple queries into\n * a single, easy accessible collection.\n *\n * AggregateCollection is driven by the `queries` function, which defines what\n * queries should be executed on the Firestore cloud back-end. GeoQuery is\n * for instance a more specific use-case of a aggregated-collection using a range\n * of geo-hash queries.\n *\n * @param {CollectionSource} [source] String-path, ref or function that returns a path or ref\n * @param {Object} [options] Configuration options\n * @param {AggregateCollectionQueriesFn} [options.queries] See `AggregateCollection.queries`\n * @param {Function} [options.createDocument] Factory function for creating documents `(source, options) => new Document(source, options)`\n * @param {Function} [options.orderBy] Client side sort function\n * @param {Function} [options.filterBy] Client side filter function\n * @param {boolean} [options.debug] Enables debug logging\n * @param {String} [options.debugName] Name to use when debug logging is enabled\n *\n * @example\n * import {AggregateCollection} from 'firestorter';\n *\n * // Query all unfinished todos for a set of users\n * const userIds = ['pinky', 'brain'];\n * const col = new AggregateCollection('todos', {\n *   queries: () => userIds.map(userId => ({\n *     key: userId, // unique-key by which the query is re-used/cached\n *     query: (ref) => ref.where('userId', '==', userId).where('finished', '==', false)\n *   }))\n * });\n */\nclass AggregateCollection<\n  T extends ICollectionDocument,\n  Y extends IAggregateCollectionQuery = IAggregateCollectionQuery\n> implements ICollection<T>, IEnhancedObservableDelegate, IHasContext\n{\n  private queriesFn: AggregateCollectionQueriesFn<Y>;\n  private collectionSource: CollectionSource;\n  private createDocument: (source: DocumentSource, options: IDocumentOptions) => T;\n  private orderBy?: AggregateCollectionOrderBy<T>;\n  private filterBy?: AggregateCollectionFilterBy<T>;\n  private debug: boolean;\n  private debugInstanceName?: string;\n  private observedRefCount: number = 0;\n  private disposer?: (() => any);\n  private collections: IObservableArray<Collection<T>>;\n  private prevCollections: Collection<T>[];\n  private collectionRecycleMap: {\n    [key: string]: Collection<T>;\n  };\n  private documentRecycleMap: {\n    [key: string]: T;\n  };\n  private ctx?: IContext;\n\n  constructor(source: CollectionSource, options: IAggregateCollectionOptions<T, Y>) {\n    makeObservable(this, {\n      docs: computed,\n    });\n\n    this.collectionSource = source;\n    if (options.createDocument) {\n      this.createDocument = options.createDocument;\n    } else {\n      this.createDocument = (docSource: DocumentSource, docOptions: IDocumentOptions): T =>\n        new Document(docSource, docOptions) as unknown as T;\n    }\n    this.queriesFn = options.queries;\n    this.orderBy = options.orderBy;\n    this.filterBy = options.filterBy;\n    this.debug = options.debug || false;\n    this.debugInstanceName = options.debugName;\n    this.collections = enhancedObservable([], this);\n    this.prevCollections = [];\n    this.collectionRecycleMap = {};\n    this.documentRecycleMap = {};\n    this.ctx = options.context;\n  }\n\n  /**\n   * Array of all the documents that have been fetched\n   * from firestore.\n   *\n   * @type {Array}\n   *\n   * @example\n   * aggregateCollection.docs.forEach((doc) => {\n   *   console.log(doc.data);\n   * });\n   */\n  public get docs(): T[] {\n    let docs: T[] = [];\n\n    // Aggregrate all docs from the queries\n    let hasAllData = true;\n    this.collections.forEach((col) => {\n      if (col.isLoading) {\n        hasAllData = false;\n      }\n      col.docs.forEach((doc) => docs.push(doc));\n    });\n\n    // If new queries have been added but have not yet\n    // completed loading, use the previous queries instead\n    // (until) all data has loaded\n    if (!hasAllData && this.prevCollections.length) {\n      // console.log('usingPrevQueries');\n      docs = [];\n      this.prevCollections.forEach((col) => {\n        col.docs.forEach((doc) => docs.push(doc));\n      });\n    } else if (hasAllData) {\n      // console.log('+++ ALL DATA AVAIL');\n      this.prevCollections = this.collections.slice(0);\n    }\n\n    // console.log('unfilteredDocs: ', docs.length);\n    if (this.filterBy) {\n      docs = docs.filter(this.filterBy);\n    }\n    if (this.orderBy) {\n      docs.sort(this.orderBy);\n    }\n    // console.log('docs: ', docs.length);\n    return docs;\n  }\n\n  /**\n   * True whenever any documents have been fetched.\n   *\n   * @type {boolean}\n   */\n  public get hasDocs(): boolean {\n    return this.docs.length > 0;\n  }\n\n  /**\n   * Array of all the collections inside this aggregate\n   * collection.\n   *\n   * @type {Array}\n   *\n   * @example\n   * aggregateCollection.cols.forEach((col) => {\n   *   console.log(col.docs.length);\n   * });\n   */\n  public get cols(): Collection<T>[] {\n    return this.collections;\n  }\n\n  /**\n   * Queries function.\n   *\n   * @type {Function}\n   */\n  public get queries(): AggregateCollectionQueriesFn<Y> {\n    return this.queriesFn;\n  }\n\n  /**\n   * True when new data is being loaded.\n   *\n   * @type {boolean}\n   */\n  public get isLoading(): boolean {\n    return this.collections.reduce((acc, col) => acc || col.isLoading, false) as any;\n  }\n\n  /**\n   * True when data for all underlying collections has been loaded.\n   *\n   * @type {boolean}\n   */\n  public get isLoaded(): boolean {\n    return this.collections.reduce((acc, col) => (acc ? col.isLoaded : false), true) as any;\n  }\n\n  /**\n   * @private\n   */\n  public get debugName(): string {\n    return `${this.debugInstanceName || this.constructor.name}`;\n  }\n\n  public toString(): string {\n    return this.debugName;\n  }\n\n  /**\n   * @private\n   */\n  public get context(): IContext | undefined {\n    return this.ctx;\n  }\n\n  /**\n   * Called whenever a property of this class becomes observed.\n   * @private\n   */\n  public addObserverRef(): number {\n    const res = ++this.observedRefCount;\n    if (res === 1) {\n      this.disposer = autorun(() => {\n        const queries = this.queriesFn();\n        runInAction(() => this._updateQueries(queries));\n      });\n    }\n    return res;\n  }\n\n  /**\n   * Called whenever a property of this class becomes un-observed.\n   * @private\n   */\n  public releaseObserverRef(): number {\n    const res = --this.observedRefCount;\n    if (res <= 0) {\n      if (this.disposer) {\n        this.disposer();\n        this.disposer = undefined;\n      }\n    }\n    return res;\n  }\n\n  /**\n   * @private\n   */\n  private _onCreateDocument = (source: DocumentSource, options: IDocumentOptions) => {\n    if (!source) {\n      return this.createDocument(source, options);\n    }\n    // @ts-ignore\n    const doc = source.id ? this.documentRecycleMap[source.id] : null;\n    return doc || this.createDocument(source, options);\n  };\n\n  /**\n   * @private\n   */\n  private _updateQueries(queries: AggregateCollectionQueries<Y>) {\n    if (!queries) {\n      return;\n    }\n    if (this.debug) {\n      console.debug(this.debugName, 'updateQueries: ', queries);\n    }\n\n    // Copy all current documents into the document recyle map\n    this.documentRecycleMap = {};\n    Object.values(this.collectionRecycleMap).forEach((query) => {\n      query.docs.forEach((doc) => {\n        this.documentRecycleMap[doc.id!] = doc;\n      });\n    });\n    // console.log(Object.keys(this._documentRecycleMap));\n\n    const cols = queries.map((query) => {\n      let col = this.collectionRecycleMap[query.key];\n      if (!col) {\n        col = new Collection(this.collectionSource, {\n          createDocument: this._onCreateDocument,\n          debug: this.debug,\n          debugName: this.debugName + '.col: ' + query.key,\n          query: (ref) => (ref ? query.query(ref) : ref),\n        });\n      }\n      return col;\n    });\n\n    // Update the query recycle map\n    this.collectionRecycleMap = {};\n    cols.forEach((col, index) => {\n      const query = queries[index];\n      this.collectionRecycleMap[query.key] = col;\n    });\n\n    // Update the queries\n    if (!isEqual(cols, this.collections.slice(0))) {\n      this.collections.replace(cols);\n    }\n  }\n}\n\nexport default AggregateCollection;\n","// Taken from https://github.com/firebase/geofire-js/blob/master/src/utils.ts\n// And slightly modified to remove warnings and add the IGeoPoint type.\n\nexport interface IGeoPoint {\n  readonly latitude: number;\n  readonly longitude: number;\n}\n\nexport interface IGeoRegion extends IGeoPoint {\n  readonly latitudeDelta: number;\n  readonly longitudeDelta: number;\n}\n\nexport type GeoHash = string;\n\n// Default geohash length\nconst GEOHASH_PRECISION = 10;\n\n// Characters used in location geohashes\nconst BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n\n// The meridional circumference of the earth in meters\nconst EARTH_MERI_CIRCUMFERENCE = 40007860;\n\n// Length of a degree latitude at the equator\nconst METERS_PER_DEGREE_LATITUDE = 110574;\n\n// Number of bits per geohash character\nconst BITS_PER_CHAR = 5;\n\n// Maximum length of a geohash in bits\nconst MAXIMUM_BITS_PRECISION = 22 * BITS_PER_CHAR;\n\n// Equatorial radius of the earth in meters\nconst EARTH_EQ_RADIUS = 6378137.0;\n\n// The following value assumes a polar radius of\n// const EARTH_POL_RADIUS = 6356752.3;\n// The formulate to calculate E2 is\n// E2 == (EARTH_EQ_RADIUS^2-EARTH_POL_RADIUS^2)/(EARTH_EQ_RADIUS^2)\n// The exact value is used here to avoid rounding errors\nconst E2 = 0.00669447819799;\n\n// Cutoff for rounding errors on double calculations\nconst EPSILON = 1e-12;\n\n/*\nfunction fromGeoPoint(point: IGeoPoint): number[] {\n\treturn [point.latitude, point.longitude];\n} */\n\nfunction toGeoPoint(location: number[]): IGeoPoint {\n  return {\n    latitude: location[0],\n    longitude: location[1],\n  };\n}\n\nfunction log2(x: number): number {\n  return Math.log(x) / Math.log(2);\n}\n\n/**\n * Validates the inputted location and throws an error if it is invalid.\n * @private\n * @param {object} location The {latitude, longitude} to be verified.\n */\nfunction validateLatitude(latitude: number): void {\n  if (typeof latitude !== 'number' || isNaN(latitude)) {\n    throw new Error('latitude must be a number');\n  } else if (latitude < -90 || latitude > 90) {\n    throw new Error('latitude must be within the range [-90, 90]');\n  }\n}\n\n/**\n * @private\n */\nfunction validateLongitude(longitude: number): void {\n  if (typeof longitude !== 'number' || isNaN(longitude)) {\n    throw new Error('longitude must be a number');\n  } else if (longitude < -180 || longitude > 180) {\n    throw new Error('longitude must be within the range [-180, 180]');\n  }\n}\n\n/**\n * @private\n */\nfunction validateLocation(location: IGeoPoint): void {\n  try {\n    if (!location) {\n      throw new Error('location is empty');\n    }\n    validateLatitude(location.latitude);\n    validateLongitude(location.longitude);\n  } catch (err) {\n    throw new Error(`Invalid location \"${location}\": ${(err as Error).message}`);\n  }\n}\n\n/**\n * @private\n */\nfunction validateRegion(region: IGeoRegion): void {\n  try {\n    if (!region) {\n      throw new Error('region is empty');\n    }\n    validateLatitude(region.latitude);\n    validateLatitude(region.latitudeDelta);\n    validateLongitude(region.longitude);\n    validateLongitude(region.longitudeDelta);\n  } catch (err) {\n    throw new Error(`Invalid region \"${region}\": ${(err as Error).message}`);\n  }\n}\n\n/**\n * Validates the inputted geohash and throws an error if it is invalid.\n * @private\n * @param {string} geohash The geohash to be validated.\n */\nfunction validateGeohash(geohash: string): void {\n  let error;\n\n  if (typeof geohash !== 'string') {\n    error = 'geohash must be a string';\n  } else if (geohash.length === 0) {\n    error = 'geohash cannot be the empty string';\n  } else {\n    for (const letter of geohash) {\n      if (BASE32.indexOf(letter) === -1) {\n        error = \"geohash cannot contain '\" + letter + \"'\";\n      }\n    }\n  }\n\n  if (typeof error !== 'undefined') {\n    throw new Error(\"Invalid geohash '\" + geohash + \"': \" + error);\n  }\n}\n\n/**\n * Converts a region into its geo points (nortEast, southWest, etc..).\n *\n * @param {IGeoRegion} region The region to convert\n */\nexport function geoRegionToPoints(\n  region: IGeoRegion\n): {\n  northEast: IGeoPoint;\n  northWest: IGeoPoint;\n  southEast: IGeoPoint;\n  southWest: IGeoPoint;\n} {\n  const north = region.latitude - region.latitudeDelta * 0.5;\n  const south = region.latitude + region.latitudeDelta * 0.5;\n  const east = wrapLongitude(region.longitude + region.longitudeDelta * 0.5);\n  const west = wrapLongitude(region.longitude - region.longitudeDelta * 0.5);\n  return {\n    northEast: { latitude: north, longitude: east },\n    northWest: { latitude: north, longitude: west },\n    southEast: { latitude: south, longitude: east },\n    southWest: { latitude: south, longitude: west },\n  };\n}\n\n/**\n * Converts degrees to radians.\n * @private\n * @param {number} degrees The number of degrees to be converted to radians.\n * @returns The number of radians equal to the inputted number of degrees.\n */\nfunction degreesToRadians(degrees: number): number {\n  if (typeof degrees !== 'number' || isNaN(degrees)) {\n    throw new Error('Error: degrees must be a number');\n  }\n\n  return (degrees * Math.PI) / 180;\n}\n\n/**\n * Encodes a geographical position (latitude/longitude) into a geohash tile.\n *\n * @param {object} location The {latitude, longitude} to encode into a geohash.\n * @param {number} [precision] The length of the geohash to create. If no precision is specified, the\n * default precision of `10` is used.\n * @returns The geohash of the inputted location.\n */\nexport function encodeGeohash(location: IGeoPoint, precision: number = GEOHASH_PRECISION): string {\n  validateLocation(location);\n  if (typeof precision !== 'undefined') {\n    if (typeof precision !== 'number' || isNaN(precision)) {\n      throw new Error('precision must be a number');\n    } else if (precision <= 0) {\n      throw new Error('precision must be greater than 0');\n    } else if (precision > 22) {\n      throw new Error('precision cannot be greater than 22');\n    } else if (Math.round(precision) !== precision) {\n      throw new Error('precision must be an integer');\n    }\n  }\n\n  const latitudeRange = {\n    max: 90,\n    min: -90,\n  };\n  const longitudeRange = {\n    max: 180,\n    min: -180,\n  };\n  let hash = '';\n  let hashVal = 0;\n  let bits = 0;\n  let even: number | boolean = 1;\n\n  while (hash.length < precision) {\n    const val = even ? location.longitude : location.latitude;\n    const range = even ? longitudeRange : latitudeRange;\n    const mid = (range.min + range.max) / 2;\n\n    if (val > mid) {\n      hashVal = (hashVal << 1) + 1;\n      range.min = mid;\n    } else {\n      hashVal = (hashVal << 1) + 0;\n      range.max = mid;\n    }\n\n    even = !even;\n    if (bits < 4) {\n      bits++;\n    } else {\n      bits = 0;\n      hash += BASE32[hashVal];\n      hashVal = 0;\n    }\n  }\n\n  return hash;\n}\n\n/**\n * Decodes a geohash tile into a geographical position (latitude/longitude).\n *\n * @param {string} geohash - Geohash tile\n */\nexport function decodeGeohash(geohash: string): IGeoPoint[] {\n  validateGeohash(geohash);\n\n  let evenBit = true;\n  let latMin = -90;\n  let latMax = 90;\n  let lonMin = -180;\n  let lonMax = 180;\n\n  for (let i = 0; i < geohash.length; i++) {\n    const chr = geohash.charAt(i);\n    const idx = BASE32.indexOf(chr);\n    if (idx < 0) {\n      throw new Error('Invalid geohash');\n    }\n\n    for (let n = 4; n >= 0; n--) {\n      const bitN = (idx >> n) & 1;\n      if (evenBit) {\n        // longitude\n        const lonMid = (lonMin + lonMax) / 2;\n        if (bitN === 1) {\n          lonMin = lonMid;\n        } else {\n          lonMax = lonMid;\n        }\n      } else {\n        // latitude\n        const latMid = (latMin + latMax) / 2;\n        if (bitN === 1) {\n          latMin = latMid;\n        } else {\n          latMax = latMid;\n        }\n      }\n      evenBit = !evenBit;\n    }\n  }\n\n  return [\n    { latitude: latMin, longitude: lonMin }, // sw\n    { latitude: latMax, longitude: lonMax }, // ne\n  ];\n}\n\n/**\n * Calculates the number of longitude degrees over a given distance and at a given latitude.\n *\n * @param {number} distance The distance to convert.\n * @param {number} latitude The latitude at which to calculate.\n * @returns The number of degrees the distance corresponds to.\n */\nexport function metersToLongitudeDegrees(distance: number, latitude: number): number {\n  const radians = degreesToRadians(latitude);\n  const num = (Math.cos(radians) * EARTH_EQ_RADIUS * Math.PI) / 180;\n  const denom = 1 / Math.sqrt(1 - E2 * Math.sin(radians) * Math.sin(radians));\n  const deltaDeg = num * denom;\n  if (deltaDeg < EPSILON) {\n    return distance > 0 ? 360 : 0;\n  } else {\n    return Math.min(360, distance / deltaDeg);\n  }\n}\n\n/**\n * Calculates the number of latitude degrees over a given distance.\n *\n * @param {number} distance The distance to convert.\n * @returns The number of degrees the distance corresponds to.\n */\nexport function metersToLatitudeDegrees(distance: number): number {\n  return distance / METERS_PER_DEGREE_LATITUDE;\n}\n\n/**\n * Calculates the bits necessary to reach a given resolution, in meters, for the longitude at a\n * given latitude.\n * @ignore\n * @param {number} resolution The desired resolution.\n * @param {number} latitude The latitude used in the conversion.\n * @return The bits necessary to reach a given resolution, in meters.\n */\nexport function longitudeBitsForResolution(resolution: number, latitude: number): number {\n  const degs = metersToLongitudeDegrees(resolution, latitude);\n  return Math.abs(degs) > 0.000001 ? Math.max(1, log2(360 / degs)) : 1;\n}\n\n/**\n * Calculates the bits necessary to reach a given resolution, in meters, for the latitude.\n * @ignore\n * @param {number} resolution The bits necessary to reach a given resolution, in meters.\n * @returns Bits necessary to reach a given resolution, in meters, for the latitude.\n */\nexport function latitudeBitsForResolution(resolution: number): number {\n  return Math.min(log2(EARTH_MERI_CIRCUMFERENCE / 2 / resolution), MAXIMUM_BITS_PRECISION);\n}\n\n/**\n * Wraps the longitude to [-180,180].\n * @private\n * @param {number} longitude The longitude to wrap.\n * @returns longitude The resulting longitude.\n */\nexport function wrapLongitude(longitude: number): number {\n  if (longitude <= 180 && longitude >= -180) {\n    return longitude;\n  }\n  const adjusted = longitude + 180;\n  if (adjusted > 0) {\n    return (adjusted % 360) - 180;\n  } else {\n    return 180 - (-adjusted % 360);\n  }\n}\n\n/**\n * Calculates the maximum number of bits of a geohash to get a bounding box that is larger than a\n * given size at the given coordinate.\n * @ignore\n * @param {object} coordinate The coordinate as a {latitude, longitude}.\n * @param {number} size The size of the bounding box.\n * @returns The number of bits necessary for the geohash.\n */\nfunction boundingBoxBits(coordinate: IGeoPoint, size: number): number {\n  const latDeltaDegrees = size / METERS_PER_DEGREE_LATITUDE;\n  const latitudeNorth = Math.min(90, coordinate.latitude + latDeltaDegrees);\n  const latitudeSouth = Math.max(-90, coordinate.latitude - latDeltaDegrees);\n  const bitsLat = Math.floor(latitudeBitsForResolution(size)) * 2;\n  const bitsLongNorth = Math.floor(longitudeBitsForResolution(size, latitudeNorth)) * 2 - 1;\n  const bitsLongSouth = Math.floor(longitudeBitsForResolution(size, latitudeSouth)) * 2 - 1;\n  return Math.min(bitsLat, bitsLongNorth, bitsLongSouth, MAXIMUM_BITS_PRECISION);\n}\nfunction boundingBoxBitsForRegion(region: IGeoRegion): number {\n  const { northEast, southEast, northWest, southWest } = geoRegionToPoints(region);\n  const bitsLat =\n    Math.floor(latitudeBitsForResolution(calculateGeoDistance(northEast, southEast) * 0.5)) * 2;\n  const bitsLongNorth =\n    Math.floor(\n      longitudeBitsForResolution(\n        calculateGeoDistance(northEast, northWest) * 0.5,\n        northWest.latitude\n      )\n    ) *\n      2 -\n    1;\n  const bitsLongSouth =\n    Math.floor(\n      longitudeBitsForResolution(\n        calculateGeoDistance(southEast, southWest) * 0.5,\n        southWest.latitude\n      )\n    ) *\n      2 -\n    1;\n  return Math.min(bitsLat, bitsLongNorth, bitsLongSouth, MAXIMUM_BITS_PRECISION);\n}\n\n/**\n * Calculates eight points on the bounding box and the center of a given circle. At least one\n * geohash of these nine coordinates, truncated to a precision of at most radius, are guaranteed\n * to be prefixes of any geohash that lies within the circle.\n * @ignore\n * @param {object} center The center given as {latitude, longitude}.\n * @param {number} radius The radius of the circle in meters.\n * @returns The eight bounding box points.\n */\nfunction boundingBoxCoordinates(center: IGeoPoint, radius: number): number[][] {\n  const latDegrees = radius / METERS_PER_DEGREE_LATITUDE;\n  const latitudeNorth = Math.min(90, center.latitude + latDegrees);\n  const latitudeSouth = Math.max(-90, center.latitude - latDegrees);\n  const longDegsNorth = metersToLongitudeDegrees(radius, latitudeNorth);\n  const longDegsSouth = metersToLongitudeDegrees(radius, latitudeSouth);\n  const longDegs = Math.max(longDegsNorth, longDegsSouth);\n  return [\n    [center.latitude, center.longitude],\n    [center.latitude, wrapLongitude(center.longitude - longDegs)],\n    [center.latitude, wrapLongitude(center.longitude + longDegs)],\n    [latitudeNorth, center.longitude],\n    [latitudeNorth, wrapLongitude(center.longitude - longDegs)],\n    [latitudeNorth, wrapLongitude(center.longitude + longDegs)],\n    [latitudeSouth, center.longitude],\n    [latitudeSouth, wrapLongitude(center.longitude - longDegs)],\n    [latitudeSouth, wrapLongitude(center.longitude + longDegs)],\n  ];\n}\n\n/**\n * Calculates eight points on the bounding box and the center of a region box. At least one\n * geohash of these nine coordinates, truncated to a precision of at most radius, are guaranteed\n * to be prefixes of any geohash that lies within the circle.\n * @ignore\n * @param {object} region The region given as {latitude, longitude, latitudeDelta, longitudeDelta}.\n * @returns The eight bounding box points.\n */\nfunction boundingBoxCoordinatesForRegion(region: IGeoRegion): number[][] {\n  const { northEast, northWest, southWest } = geoRegionToPoints(region);\n  return [\n    [region.latitude, region.longitude],\n    [region.latitude, northEast.longitude],\n    [region.latitude, northWest.longitude],\n    [northWest.latitude, region.longitude],\n    [northWest.latitude, northEast.longitude],\n    [northWest.latitude, northWest.longitude],\n    [southWest.latitude, region.longitude],\n    [southWest.latitude, northEast.longitude],\n    [southWest.latitude, northWest.longitude],\n  ];\n}\n\n/**\n * Calculates the bounding box query for a geohash with x bits precision.\n * @ignore\n * @param {string} geohash The geohash whose bounding box query to generate.\n * @param {number} bits The number of bits of precision.\n * @returns A [start, end] pair of geohashes.\n */\nfunction geohashQuery(geohash1: string, bits: number): string[] {\n  validateGeohash(geohash1);\n  const precision = Math.ceil(bits / BITS_PER_CHAR);\n  if (geohash1.length < precision) {\n    return [geohash1, geohash1 + '~'];\n  }\n  const geohash = geohash1.substring(0, precision);\n  const base = geohash.substring(0, geohash.length - 1);\n  const lastValue = BASE32.indexOf(geohash.charAt(geohash.length - 1));\n  const significantBits = bits - base.length * BITS_PER_CHAR;\n  const unusedBits = BITS_PER_CHAR - significantBits;\n  // delete unused bits\n  const startValue = (lastValue >> unusedBits) << unusedBits;\n  const endValue = startValue + (1 << unusedBits);\n  if (endValue > 31) {\n    return [base + BASE32[startValue], base + '~'];\n  } else {\n    return [base + BASE32[startValue], base + BASE32[endValue]];\n  }\n}\n\n/**\n * Calculates a set of geohash queries to fully contain a given circle. A query is a [start, end] pair\n * where any geohash is guaranteed to be lexiographically larger then start and smaller than end.\n *\n * @param {object} center The center given as {latitude, longitude}.\n * @param {number} radius The radius of the circle in meters.\n * @return An array of geohashes containing a [start, end] pair.\n */\nexport function getGeohashesForRadius(center: IGeoPoint, radius: number): string[][] {\n  validateLocation(center);\n  const bits = Math.max(1, boundingBoxBits(center, radius));\n  const precision = Math.ceil(bits / BITS_PER_CHAR);\n  const coordinates = boundingBoxCoordinates(center, radius);\n  const queries = coordinates.map(coordinate => {\n    return geohashQuery(encodeGeohash(toGeoPoint(coordinate), precision), bits);\n  });\n  // remove duplicates\n  return queries.filter((query, index) => {\n    return !queries.some((other, otherIndex) => {\n      return index > otherIndex && query[0] === other[0] && query[1] === other[1];\n    });\n  });\n}\n\n/**\n * Calculates a set of geohash queries to fully contain a given region box. A query is a [start, end] pair\n * where any geohash is guaranteed to be lexiographically larger then start and smaller than end.\n *\n * @param {object} region The region given as {latitude, longitude, latitudeDelta, longitudeDelta}.\n * @return An array of geohashes containing a [start, end] pair.\n */\nexport function getGeohashesForRegion(region: IGeoRegion): string[][] {\n  validateRegion(region);\n  const bits = Math.max(1, boundingBoxBitsForRegion(region));\n  const precision = Math.ceil(bits / BITS_PER_CHAR);\n  const coordinates = boundingBoxCoordinatesForRegion(region);\n  const queries = coordinates.map(coordinate => {\n    const geohash = encodeGeohash(toGeoPoint(coordinate), precision);\n    const query = geohashQuery(geohash, bits);\n    /* console.log(\n\t\t\tgeohash,\n\t\t\t\", index: \",\n\t\t\tindex,\n\t\t\t\", query: \",\n\t\t\tquery,\n\t\t\t\", precision: \",\n\t\t\tprecision\n\t\t); */\n    return query;\n  });\n  // remove duplicates\n  return queries.filter((query, index) => {\n    return !queries.some((other, otherIndex) => {\n      return index > otherIndex && query[0] === other[0] && query[1] === other[1];\n    });\n  });\n}\n\n/**\n * Flattens a query start-geohash; and end-geohash into all its individual geohash components.\n *\n * @param {string} geohash1 The geohash from range\n * @param {string} geohash2 The geohash to range\n */\nexport function flattenGeohashRange(geohash1: string, geohash2: string): string[] {\n  if (geohash1.length !== geohash2.length) {\n    throw new Error('Geohash lengths must be the same');\n  }\n  const res: string[] = [geohash1];\n  let hash = geohash1;\n  while (hash < geohash2) {\n    for (let i = geohash1.length - 1; i >= 0; i--) {\n      const idx = BASE32.indexOf(hash.charAt(i));\n      if (idx < BASE32.length - 1) {\n        hash = hash.substring(0, i) + BASE32[idx + 1] + hash.substring(i + 1);\n        if (hash < geohash2) {\n          res.push(hash);\n        }\n        break;\n      } else {\n        hash = hash.substring(0, i) + BASE32[0] + hash.substring(i + 1);\n      }\n      if (hash >= geohash2) {\n        break;\n      }\n    }\n  }\n  return res;\n}\n\n/**\n * Flattens a set of geo-hash queries into a single array of geohash tiles.\n *\n * @param {string[][]} geohashes The geohashes array\n */\nexport function flattenGeohashes(geohashes: string[][]): string[] {\n  const set = new Set<string>();\n  geohashes.forEach(a => flattenGeohashRange(a[0], a[1]).forEach(geohash => set.add(geohash)));\n  return Array.from(set);\n}\n\n/**\n * Method which calculates the distance, in meters, between two locations,\n * via the Haversine formula. Note that this is approximate due to the fact that the\n * Earth's radius varies between 6356.752 km and 6378.137 km.\n *\n * @param {object} location1 The {latitude, longitude} of the first location.\n * @param {object} location2 The {latitude, longitude} of the second location.\n * @returns The distance, in meters, between the inputted locations.\n */\nexport function calculateGeoDistance(location1: IGeoPoint, location2: IGeoPoint): number {\n  validateLocation(location1);\n  validateLocation(location2);\n\n  const radius = 6371; // Earth's radius in kilometers\n  const latDelta = degreesToRadians(location2.latitude - location1.latitude);\n  const lonDelta = degreesToRadians(location2.longitude - location1.longitude);\n\n  const a =\n    Math.sin(latDelta / 2) * Math.sin(latDelta / 2) +\n    Math.cos(degreesToRadians(location1.latitude)) *\n      Math.cos(degreesToRadians(location2.latitude)) *\n      Math.sin(lonDelta / 2) *\n      Math.sin(lonDelta / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return radius * c * 1000;\n}\n\nexport function insideGeoRegion(point: IGeoPoint, region: IGeoRegion): boolean {\n  if (\n    point.latitude < region.latitude - region.latitudeDelta * 0.5 ||\n    point.latitude > region.latitude + region.latitudeDelta * 0.5\n  ) {\n    return false;\n  }\n  // TODO - wrap longitude?\n  if (\n    point.longitude < region.longitude - region.longitudeDelta * 0.5 ||\n    point.longitude > region.longitude + region.longitudeDelta * 0.5\n  ) {\n    return false;\n  }\n  return true;\n}\n","import { runInAction, observable, makeObservable, computed, IObservableValue } from 'mobx';\n\nimport AggregateCollection, {\n  IAggregateCollectionOptions,\n  IAggregateCollectionQuery,\n  AggregateCollectionQueriesFn,\n} from './AggregateCollection';\nimport { IGeoRegion, getGeohashesForRegion } from './GeoHash';\nimport { CollectionSource, ICollectionDocument } from './Types';\nimport { getContext } from './init';\n\nexport type GeoQueryRegion = IGeoRegion | (() => IGeoRegion | void);\nexport type GeoQueryHash = string[];\n\nexport interface IGeoQueryQuery extends IAggregateCollectionQuery {\n  geohash: GeoQueryHash;\n}\n\nexport interface IGeoQueryOptions<T>\n  extends Omit<IAggregateCollectionOptions<T, IGeoQueryQuery>, 'queries'> {\n  queries?: AggregateCollectionQueriesFn<IGeoQueryQuery>;\n  region?: GeoQueryRegion;\n  fieldPath?: string;\n  filterBy?: (doc: T, region?: IGeoRegion | void) => boolean;\n}\n\n/**\n * GeoQuery makes it possible to perform efficient geographical based queries\n * with the use of geo-hashes.\n *\n * In order to use GeoQuery, each document needs a `geohash` field stored in the\n * root of the document. The value of the `geohash` field should be a geo-hash\n * encoded using `encodeGeohash`.\n *\n * @extends AggregateCollection\n * @param {CollectionSource} [source] String-path, ref or function that returns a path or ref\n * @param {Object} [options] Configuration options\n * @param {IGeoRegion} [options.region] See `GeoQuery.region`\n * @param {string} [options.fieldPath] Field to query on (default = `geohash`)\n *\n * @example\n *\n * const query = new GeoQuery('bookings', {\n *   region = {\n *     latitude: 51.45663,\n *     longitude: 5.223,\n *     latitudeDelta: 0.1,\n *     longitudeDelta: 0.1,\n *   }\n * });\n *\n * // Bookings needs to contain documents with a `geohash`\n * // field in the root, like this:\n * // {\n * //   ...\n * //   geohash: 'jhdb23'\n * //   ...\n * // }\n *\n * autorun(() => {\n *   query.docs.map(doc => console.log('doc: ', doc.id, doc.data));\n * });\n */\nclass GeoQuery<T extends ICollectionDocument> extends AggregateCollection<T, IGeoQueryQuery> {\n  private regionObservable: IObservableValue<GeoQueryRegion | void>;\n\n  constructor(source: CollectionSource, options?: IGeoQueryOptions<T>) {\n    const { region, fieldPath = 'geohash', filterBy, ...otherOptions } = options || {};\n    const regionObservable: IObservableValue<GeoQueryRegion | void> = observable.box(region);\n    super(source, {\n      filterBy: filterBy\n        ? (doc: T) => {\n            let regionVal = regionObservable.get();\n            regionVal = typeof regionVal === 'function' ? regionVal() : regionVal;\n            return filterBy(doc, regionVal);\n          }\n        : undefined,\n      queries: () => {\n        let regionVal = regionObservable.get();\n        regionVal = typeof regionVal === 'function' ? regionVal() : regionVal;\n        const geohashes = regionVal ? getGeohashesForRegion(regionVal) : undefined;\n        if (!geohashes) {\n          return null;\n        }\n        const { query, where } = getContext(this);\n        return geohashes.map(geohash => ({\n          geohash,\n          key: `${geohash[0]}-${geohash[1]}`,\n          query: ref =>\n            query(ref, where(fieldPath, '>=', geohash[0]), where(fieldPath, '<', geohash[1])),\n        }));\n      },\n      ...otherOptions,\n    });\n    this.regionObservable = regionObservable;\n    makeObservable(this, {\n      geohashes: computed,\n    });\n  }\n\n  /**\n   * Geographical region to query for.\n   *\n   * Use this property to get or set the region in which\n   * to perform a aggregate geohash query.\n   *\n   * @type {GeoQueryRegion}\n   *\n   * @example\n   * const query = new GeoQuery('bookings');\n   *\n   * // Bookings needs to contain documents with a `geohash`\n   * // field in the root, like this:\n   * // {\n   * //   ...\n   * //   geohash: 'jhdb23'\n   * //   ...\n   * // }\n   *\n   * ...\n   * // Set the region to query for\n   * query.region = {\n   *   latitude: 51.45663,\n   *   longitude: 5.223,\n   *   latitudeDelta: 0.1,\n   *   longitudeDelta: 0.1,\n   * }\n   */\n  get region(): GeoQueryRegion | void {\n    return this.regionObservable.get();\n  }\n  set region(val: GeoQueryRegion | void) {\n    runInAction(() => this.regionObservable.set(val));\n  }\n\n  /**\n   * Geo-hashes that are queries for the given region.\n   *\n   * @type {GeoQueryHash[]}\n   *\n   * @example\n   * const query = new GeoQuery('bookings', {\n   *   region: {\n   *     latitude: 51.45663,\n   *     longitude: 5.223,\n   *     latitudeDelta: 0.1,\n   *     longitudeDelta: 0.1\n   *   }\n   * });\n   * ...\n   * // Get the in-use geohashes\n   * console.log(query.geohashes);\n   * // [['todo', 'todo2], ...]\n   */\n  get geohashes(): GeoQueryHash[] {\n    const queries = this.queries();\n    return queries ? queries.map(query => query.geohash) : [];\n  }\n}\n\nexport default GeoQuery;\n","import AggregateCollection from './AggregateCollection';\nimport Collection from './Collection';\nimport Document from './Document';\nimport {\n  decodeGeohash,\n  encodeGeohash,\n  getGeohashesForRadius,\n  getGeohashesForRegion,\n  flattenGeohashRange,\n  flattenGeohashes,\n  calculateGeoDistance,\n  insideGeoRegion,\n  geoRegionToPoints,\n  metersToLatitudeDegrees,\n  metersToLongitudeDegrees,\n} from './GeoHash';\nimport GeoQuery from './GeoQuery';\nimport { Mode } from './Types';\nimport { mergeUpdateData, isTimestamp } from './Utils';\n\nexport * from './init';\nexport * from './compat';\n// export * from './init/web'; // <-- This one might causes problems on RN\n\nexport {\n  Collection,\n  Document,\n  AggregateCollection,\n  mergeUpdateData,\n  Mode,\n  isTimestamp,\n  // Geo queries\n  GeoQuery,\n  decodeGeohash,\n  encodeGeohash,\n  getGeohashesForRadius,\n  getGeohashesForRegion,\n  flattenGeohashRange,\n  flattenGeohashes,\n  calculateGeoDistance,\n  insideGeoRegion,\n  geoRegionToPoints,\n  metersToLatitudeDegrees,\n  metersToLongitudeDegrees,\n};\nexport type {\n  DocumentSource,\n  IDocumentOptions,\n  IDocument,\n  ICollection,\n  CollectionSource,\n  CollectionQuery,\n  ICollectionOptions,\n  ICollectionDocument,\n  IContext,\n  IHasContext\n} from './Types';\nexport type {\n  AggregateCollectionOrderBy,\n  AggregateCollectionFilterBy,\n  IAggregateCollectionQuery,\n  AggregateCollectionQueries,\n  AggregateCollectionQueriesFn,\n  IAggregateCollectionOptions,\n} from './AggregateCollection';\nexport type { IGeoPoint, IGeoRegion, GeoHash } from './GeoHash';\nexport type { GeoQueryRegion, GeoQueryHash, IGeoQueryQuery, IGeoQueryOptions } from './GeoQuery';\n\nexport const ModuleName = 'firestorter';"],"names":["Mode","globalContext","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","makeCompatContext","config","firebase","app","firestore","collection","path","doc","getDocs","ref","get","where","fieldPath","opStr","query","where1","where2","where3","addDoc","data","add","getDoc","setDoc","options","set","updateDoc","fields","update","deleteDoc","onSnapshot","resultFn","errorFn","deleteField","FieldValue","serverTimestamp","getContext","mergeUpdateData","hasContext","res","canonicalDelete","val","isDelete","isEqual","paths","split","dataVal","verifyMode","mode","enhancedObservable","o","Array","isArray","observable","array","box","isObserved","onBecomeUnobserved","releaseObserverRef","onBecomeObserved","addObserverRef","resolveRef","EMPTY_OPTIONS","Document","source","schema","snapshot","snapshotOptions","debug","debugInstanceName","debugName","sourceInput","ctx","refObservable","docSchema","isVerbose","snapshotObservable","collectionRefCount","observedRefCount","_validateSchema","dataObservable","modeObservable","Auto","isLoadingObservable","_updateSourceObserver","On","runInAction","_this","_updateRealtimeUpdates","toJS","console","warn","merge","fetch","isActive","_this2","_ready","_updateFromSnapshot","JSON","stringify","log","_context","message","ready","readyPromise","toString","_this3","_this4","addCollectionRef","releaseCollectionRef","updateFromCollectionSnapshot","readyResolve","readyResolveFn","_this5","_onSnapshot","_this6","_onSnapshotError","force","newActive","Off","active","onSnapshotUnsubscribeFn","_this7","sourceDisposerFn","reaction","_this8","id","exists","_this$refObservable","parent","documentPath","_this9","_this10","Collection","createDocument","minimizeUpdates","initialLocalSnapshotDetectTime","initialLocalSnapshotDebounceTime","isMinimizingUpdates","docLookup","queryInput","queryRefObservable","isLoadedObservable","hasDocsObservable","docsObservable","docSource","docOptions","colRef","_resolveRef","queryRef","_resolveQuery","docs","metadata","ref2","deleteAll","sourceCache","sourceCacheRef","collectionRef","initialLocalSnapshotDebounceTimer","clearTimeout","timeElapsed","Date","now","initialLocalSnapshotStartTime","setTimeout","newDocs","docSnapshot","replace","n","updateSourceRef","updateQueryRef","onSnapshotUnsubscribe","refDisposerFn","onSnapshotRefCache","initialSourceRef","initialQueryRef","sourceRef","queryRef2","docChanges","empty","size","collectionPath","_this11","AggregateCollection","documentRecycleMap","makeObservable","computed","collectionSource","queriesFn","queries","orderBy","filterBy","collections","prevCollections","collectionRecycleMap","disposer","autorun","_updateQueries","cols","map","col","_onCreateDocument","index","hasAllData","isLoading","filter","sort","reduce","acc","isLoaded","BASE32","toGeoPoint","location","latitude","longitude","log2","x","Math","validateLatitude","validateLongitude","validateLocation","validateGeohash","geohash","letter","indexOf","geoRegionToPoints","region","north","latitudeDelta","south","east","wrapLongitude","longitudeDelta","west","northEast","northWest","southEast","southWest","degreesToRadians","degrees","PI","encodeGeohash","precision","round","latitudeRange","max","min","longitudeRange","hash","hashVal","bits","even","range","mid","metersToLongitudeDegrees","distance","radians","deltaDeg","cos","sqrt","sin","longitudeBitsForResolution","resolution","degs","abs","latitudeBitsForResolution","EARTH_MERI_CIRCUMFERENCE","adjusted","geohashQuery","geohash1","ceil","substring","base","lastValue","unusedBits","startValue","endValue","getGeohashesForRegion","validateRegion","bitsLat","floor","calculateGeoDistance","bitsLongNorth","bitsLongSouth","boundingBoxBitsForRegion","boundingBoxCoordinatesForRegion","coordinate","some","other","otherIndex","flattenGeohashRange","geohash2","idx","location1","location2","latDelta","lonDelta","a","atan2","GeoQuery","otherOptions","regionObservable","regionVal","geohashes","evenBit","latMin","latMax","lonMin","lonMax","chr","bitN","lonMid","latMid","Set","from","center","radius","latDeltaDegrees","latitudeNorth","latitudeSouth","latDegrees","longDegsNorth","longDegsSouth","longDegs","boundingBoxCoordinates","point","seconds","nanoseconds"],"mappings":"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"}